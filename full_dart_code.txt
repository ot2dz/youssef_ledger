enum TransactionType { income, expense }

enum TransactionSource { cash, drawer, bank }

enum SnapshotType { start, end }
import 'package:flutter/foundation.dart';
import 'package:youssef_fabric_ledger/core/enums.dart';
import 'package:youssef_fabric_ledger/data/local/database_helper.dart';
import 'package:youssef_fabric_ledger/data/models/drawer_snapshot.dart';
import 'package:youssef_fabric_ledger/data/models/expense.dart';
import 'package:youssef_fabric_ledger/logic/providers/date_provider.dart';

enum DrawerStatus { complete, pendingEnd, missingStart }

class FinanceProvider with ChangeNotifier {
  final DatabaseHelper dbHelper;
  final DateProvider dateProvider;

  // --- Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø§Ù„ÙŠØ© ---
  double _totalCashBalance = 0.0;
  double get totalCashBalance => _totalCashBalance;

  // ... (rest of the properties are the same)
  double _grossProfit = 0.0; // = Ø±Ø¨Ø­ Ø§Ù„ÙŠÙˆÙ… (20%)
  double get grossProfit => _grossProfit;
  double get dailyProfit => _grossProfit;
  double _totalExpenses = 0.0; // Ù…ØµØ±ÙˆÙØ§Øª Ø§Ù„ÙŠÙˆÙ…
  double get totalExpenses => _totalExpenses;

  double _totalIncome = 0.0; // Ø¯Ø®Ù„ Ø§Ù„ÙŠÙˆÙ…
  double get totalIncome => _totalIncome;

  double _netProfit = 0.0; // ØµØ§ÙÙŠ Ø±Ø¨Ø­ Ø§Ù„ÙŠÙˆÙ… = Ø±Ø¨Ø­ Ø§Ù„ÙŠÙˆÙ… - Ù…ØµØ±ÙˆÙØ§Øª Ø§Ù„ÙŠÙˆÙ…
  double get netProfit => _netProfit;

  DrawerStatus _drawerStatus = DrawerStatus.pendingEnd;
  DrawerStatus get drawerStatus => _drawerStatus;

  // --- Ø£Ø±ØµØ¯Ø© Ø§Ù„Ø¯Ø±Ø¬ Ù„Ù„ÙŠÙˆÙ… ---
  double? _startOfDayBalance;
  double? get startOfDayBalance => _startOfDayBalance;

  double? _endOfDayBalance;
  double? get endOfDayBalance => _endOfDayBalance;

  double _calculatedTurnover = 0.0;
  double get calculatedTurnover => _calculatedTurnover;

  double _profitPercent = 0.20; // 20%

  Map<String, double> get drawerFinalState {
    final opening = _startOfDayBalance ?? 0.0;
    final closing = _endOfDayBalance ?? 0.0;
    // This calculation might need adjustment based on business logic
    // For now, it's a simple difference.
    final difference = closing - opening;

    return {
      'openingBalance': opening,
      'closingBalance': closing,
      'difference': difference,
    };
  }

  // --- Ø­Ø§Ù„Ø© Ø§Ù„Ø¯Ø±Ø¬ Ø§Ù„Ù…Ø­Ø¯Ø«Ø© ---
  Map<String, DrawerSnapshot?> _drawerSnapshots = {'start': null, 'end': null};
  Map<String, DrawerSnapshot?> get drawerSnapshots => _drawerSnapshots;

  // Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø´Ù‡Ø±ÙŠØ© ÙˆØ³Ù†ÙˆÙŠØ©
  double _monthlyIncome = 0.0;
  double get monthlyIncome => _monthlyIncome;

  double _monthlyExpenses = 0.0;
  double get monthlyExpenses => _monthlyExpenses;

  double _monthlyNetProfit = 0.0;
  double get monthlyNetProfit => _monthlyNetProfit;

  FinanceProvider({required this.dbHelper, required this.dateProvider}) {
    // Listen to date changes and refetch data
    dateProvider.addListener(_onDateChanged);
    loadInitialData();
  }

  void _onDateChanged() {
    fetchFinancialDataForSelectedDate();
  }

  @override
  void dispose() {
    dateProvider.removeListener(_onDateChanged);
    super.dispose();
  }

  Future<void> loadInitialData() async {
    final savedBalance = await dbHelper.getSetting('totalCashBalance');
    _totalCashBalance = double.tryParse(savedBalance ?? '0.0') ?? 0.0;
    await fetchFinancialDataForSelectedDate();
  }

  /// Fetches financial data for the date selected in DateProvider.
  Future<void> fetchFinancialDataForSelectedDate() async {
    final selectedDate = dateProvider.selectedDate;

    // 1. Fetch drawer snapshots
    final startSnapshot = await dbHelper.getSnapshotForDate(
      selectedDate,
      SnapshotType.start,
    );
    final endSnapshot = await dbHelper.getSnapshotForDate(
      selectedDate,
      SnapshotType.end,
    );

    // 2. Determine starting balance
    double? startAmount = startSnapshot?.cashAmount;
    if (startAmount == null) {
      final lastEndSnapshot = await dbHelper.getLatestEndSnapshotBefore(
        selectedDate,
      );
      startAmount = lastEndSnapshot?.cashAmount;
    }

    _startOfDayBalance = startAmount;
    _endOfDayBalance = endSnapshot?.cashAmount;

    // 3. Determine drawer status
    if (_startOfDayBalance == null) {
      _drawerStatus = DrawerStatus.missingStart;
    } else if (_endOfDayBalance == null) {
      _drawerStatus = DrawerStatus.pendingEnd;
    } else {
      _drawerStatus = DrawerStatus.complete;
    }

    // 4. Calculate turnover
    _calculatedTurnover = 0.0;
    if (_drawerStatus == DrawerStatus.complete) {
      final drawerOutflows = await dbHelper.getDrawerExpensesForDate(
        selectedDate,
      );
      final drawerInflows = await dbHelper.getDrawerIncomesForDate(
        selectedDate,
      );
      _calculatedTurnover =
          (_endOfDayBalance! - _startOfDayBalance!) +
          drawerOutflows -
          drawerInflows;
    }

    // 5. Calculate final totals
    final manualIncomes = await dbHelper.getIncomeForDate(selectedDate);
    final manualIncomesTotal = manualIncomes.fold(
      0.0,
      (sum, item) => sum + item.amount,
    );

    _totalIncome = _calculatedTurnover + manualIncomesTotal;

    final allExpenses = await dbHelper.getExpensesForDate(selectedDate);
    _totalExpenses = allExpenses.fold(0.0, (sum, item) => sum + item.amount);

    _grossProfit = _totalIncome * _profitPercent;
    _netProfit = _grossProfit - _totalExpenses;

    notifyListeners();
  }

  /// Refreshes data for the current day.
  Future<void> refreshTodayData() async {
    // This method now simply ensures the date is current and fetches data.
    // The actual date change is handled by DateProvider.
    if (!dateProvider.isSameDay(dateProvider.selectedDate, DateTime.now())) {
      dateProvider.selectDate(DateTime.now());
    } else {
      await fetchFinancialDataForSelectedDate();
    }
  }

  Future<void> updateTotalCashBalance(double newBalance) async {
    _totalCashBalance = newBalance;
    await dbHelper.saveSetting('totalCashBalance', newBalance.toString());
    notifyListeners();
  }

  Future<void> saveDrawerSnapshot({
    required DateTime date,
    required SnapshotType type,
    required double amount,
    String? note,
  }) async {
    final snapshot = DrawerSnapshot(
      date: date,
      type: type,
      cashAmount: amount,
      note: note,
      createdAt: DateTime.now(),
    );
    final savedSnapshot = await dbHelper.saveDrawerSnapshot(snapshot);
    _drawerSnapshots[type.name] = savedSnapshot;

    if (dateProvider.isSameDay(date, dateProvider.selectedDate)) {
      await fetchFinancialDataForSelectedDate();
    } else {
      notifyListeners();
    }
  }

  Future<void> addOrUpdateExpense(Expense expense) async {
    if (expense.id == null) {
      await dbHelper.createExpense(expense);
    } else {
      await dbHelper.updateExpense(expense);
    }
    // After saving, refresh the data for the currently selected date
    // to ensure the UI is up-to-date.
    await fetchFinancialDataForSelectedDate();
  }
}
import 'package:flutter/material.dart';

/// A provider dedicated to managing the selected date for the application.
///
/// This class encapsulates the logic for date selection, allowing other providers
/// and widgets to listen for and react to date changes without managing the
/// date state themselves.
class DateProvider with ChangeNotifier {
  DateTime _selectedDate = DateTime.now();

  /// The currently selected date.
  ///
  /// When a new date is set, it notifies all listeners.
  DateTime get selectedDate => _selectedDate;

  /// Updates the selected date and notifies listeners.
  ///
  /// This is the primary method for changing the application's active date.
  void selectDate(DateTime newDate) {
    if (isSameDay(_selectedDate, newDate)) return;
    _selectedDate = newDate;
    notifyListeners();
  }

  /// Moves the selected date to the next day.
  void nextDay() {
    _selectedDate = _selectedDate.add(const Duration(days: 1));
    notifyListeners();
  }

  /// Moves the selected date to the previous day.
  void previousDay() {
    _selectedDate = _selectedDate.subtract(const Duration(days: 1));
    notifyListeners();
  }

  /// Checks if two [DateTime] objects represent the same calendar day.
  bool isSameDay(DateTime a, DateTime b) {
    return a.year == b.year && a.month == b.month && a.day == b.day;
  }
}
class DrawerSnapshot {
  int? id;
  final DateTime date;
  final double startBalance;
  final double endBalance;

  DrawerSnapshot({
    this.id,
    required this.date,
    required this.startBalance,
    required this.endBalance,
  });

  factory DrawerSnapshot.fromMap(Map<String, dynamic> map) {
    return DrawerSnapshot(
      id: map['id'],
      date: DateTime.parse(map['date']),
      startBalance: map['startBalance'],
      endBalance: map['endBalance'],
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'date': date.toIso8601String().split('T').first, // YYYY-MM-DD
      'startBalance': startBalance,
      'endBalance': endBalance,
    };
  }
}import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:provider/provider.dart';
import 'package:workmanager/workmanager.dart';
import 'package:youssef_fabric_ledger/data/local/database_helper.dart';
import 'package:youssef_fabric_ledger/logic/providers/date_provider.dart';
import 'package:youssef_fabric_ledger/logic/providers/finance_provider.dart';
import 'package:youssef_fabric_ledger/presentation/screens/main_layout.dart';

// This callback is executed in a separate isolate when the background task runs.
@pragma('vm:entry-point')
void callbackDispatcher() {
  Workmanager().executeTask((task, inputData) {
    // TODO: Implement the actual backup logic by calling your BackupService.
    // final backupService = BackupService();
    // await backupService.performBackup();
    print("Native called background task: $task"); // For debugging
    return Future.value(true);
  });
}

void main() async {
  // Ensure that plugin services are initialized so that `Workmanager` can work.
  WidgetsFlutterBinding.ensureInitialized();
  // Initialize Workmanager for background tasks.
  Workmanager().initialize(callbackDispatcher, isInDebugMode: true);

  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    // MultiProvider allows us to provide multiple objects to the widget tree.
    return MultiProvider(
      providers: [
        // The DateProvider is now available to the entire app.
        ChangeNotifierProvider(create: (_) => DateProvider()),
        // FinanceProvider now depends on DateProvider.
        ChangeNotifierProxyProvider<DateProvider, FinanceProvider>(
          create: (context) => FinanceProvider(
            dbHelper: DatabaseHelper.instance,
            dateProvider: Provider.of<DateProvider>(context, listen: false),
          ),
          update: (context, dateProvider, previousFinanceProvider) =>
              FinanceProvider(
                dbHelper: DatabaseHelper.instance,
                dateProvider: dateProvider,
              ),
        ),
      ],
      child: MaterialApp(
        title: 'Ø¯ÙØªØ± Ø£Ù‚Ù…Ø´Ø© ÙŠÙˆØ³Ù',
        debugShowCheckedModeBanner: false,
        theme: ThemeData(
          // Using a modern color scheme and the recommended Tajawal font.
          colorScheme: ColorScheme.fromSeed(seedColor: const Color(0xFF2563EB)),
          useMaterial3: true,
          fontFamily: 'Tajawal',
          scaffoldBackgroundColor: const Color(0xFFF4F6F8),
          appBarTheme: const AppBarTheme(
            backgroundColor: Color(0xFF2563EB),
            foregroundColor: Colors.white,
            centerTitle: true,
            elevation: 1,
          ),
        ),
        // --- Arabic Language and RTL Support ---
        localizationsDelegates: const [
          GlobalMaterialLocalizations.delegate,
          GlobalWidgetsLocalizations.delegate,
          GlobalCupertinoLocalizations.delegate,
        ],
        supportedLocales: const [
          Locale('en', ''), // English for Latin digits
          Locale('ar', ''), // Arabic
        ],
        locale: const Locale('en', ''), // Force English locale for Latin digits
        home: const MainLayout(),
      ),
    );
  }
}
// lib/data/models/expense.dart
import 'package:youssef_fabric_ledger/core/enums.dart';

class Expense {
  final int? id;
  final DateTime date;
  final double amount;
  final int categoryId;
  final TransactionSource source;
  final String? note;
  final DateTime createdAt;

  Expense({
    this.id,
    required this.date,
    required this.amount,
    required this.categoryId,
    required this.source,
    this.note,
    required this.createdAt,
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'date': date.toIso8601String(),
      'amount': amount,
      'categoryId': categoryId,
      'source': source.name,
      'note': note,
      'createdAt': createdAt.toIso8601String(),
    };
  }

  factory Expense.fromMap(Map<String, dynamic> map) {
    return Expense(
      id: map['id'],
      date: DateTime.parse(map['date']),
      amount: (map['amount'] as num).toDouble(),
      categoryId: map['categoryId'],
      source: TransactionSource.values.byName(map['source']),
      note: map['note'],
      createdAt: DateTime.parse(map['createdAt']),
    );
  }

  Expense copyWith({
    int? id,
    DateTime? date,
    double? amount,
    int? categoryId,
    TransactionSource? source,
    String? note,
    DateTime? createdAt,
  }) {
    return Expense(
      id: id ?? this.id,
      date: date ?? this.date,
      amount: amount ?? this.amount,
      categoryId: categoryId ?? this.categoryId,
      source: source ?? this.source,
      note: note ?? this.note,
      createdAt: createdAt ?? this.createdAt,
    );
  }
}
// lib/data/models/party.dart
class Party {
  final int? id;
  final String name;
  final String type; // 'vendor' or 'person'
  final String? phone;

  Party({this.id, required this.name, required this.type, this.phone});

  Map<String, dynamic> toMap() {
    return {'id': id, 'name': name, 'type': type, 'phone': phone};
  }

  factory Party.fromMap(Map<String, dynamic> map) {
    return Party(
      id: map['id'],
      name: map['name'],
      type: map['type'],
      phone: map['phone'],
    );
  }

  Party copyWith({int? id, String? name, String? type, String? phone}) {
    return Party(
      id: id ?? this.id,
      name: name ?? this.name,
      type: type ?? this.type,
      phone: phone ?? this.phone,
    );
  }
}
// lib/data/models/income.dart

import 'package:youssef_fabric_ledger/core/enums.dart';

class Income {
  final int? id;
  final DateTime date;
  final double amount;
  final TransactionSource source;
  final String? note;
  final DateTime createdAt;

  Income({
    this.id,
    required this.date,
    required this.amount,
    required this.source,
    this.note,
    required this.createdAt,
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'date': date.toIso8601String(),
      'amount': amount,
      'source': source.name,
      'note': note,
      'createdAt': createdAt.toIso8601String(),
    };
  }

  factory Income.fromMap(Map<String, dynamic> map) {
    return Income(
      id: map['id'],
      date: DateTime.parse(map['date']),
      amount: (map['amount'] as num).toDouble(),
      source: TransactionSource.values.byName(map['source']),
      note: map['note'],
      createdAt: DateTime.parse(map['createdAt']),
    );
  }

  Income copyWith({
    int? id,
    DateTime? date,
    double? amount,
    TransactionSource? source,
    String? note,
    DateTime? createdAt,
  }) {
    return Income(
      id: id ?? this.id,
      date: date ?? this.date,
      amount: amount ?? this.amount,
      source: source ?? this.source,
      note: note ?? this.note,
      createdAt: createdAt ?? this.createdAt,
    );
  }
}
// lib/data/models/drawer_snapshot.dart
import 'package:youssef_fabric_ledger/core/enums.dart';

class DrawerSnapshot {
  final int? id;
  final DateTime date;
  final SnapshotType type;
  final double cashAmount;
  final String? note;
  final DateTime createdAt;

  DrawerSnapshot({
    this.id,
    required this.date,
    required this.type,
    required this.cashAmount,
    this.note,
    required this.createdAt,
  });

  factory DrawerSnapshot.fromMap(Map<String, dynamic> map) {
    final dateString = map['date'] as String;
    // The database might store the date as 'YYYY-MM-DD' for the UNIQUE constraint.
    // We need to parse it correctly, assuming UTC if no time is present.
    final date = dateString.length == 10
        ? DateTime.parse('${dateString}T00:00:00Z')
        : DateTime.parse(dateString);

    return DrawerSnapshot(
      id: map['id'] as int?,
      date: date,
      type: SnapshotType.values.byName(map['type'] as String),
      cashAmount: (map['cashAmount'] as num).toDouble(),
      note: map['note'] as String?,
      createdAt: DateTime.parse(map['createdAt'] as String),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'date': date.toIso8601String(),
      'type': type.name,
      'cashAmount': cashAmount,
      'note': note,
      'createdAt': createdAt.toIso8601String(),
    };
  }

  /// This map is specifically for inserting/updating the database,
  /// where the 'date' column has a UNIQUE constraint on the date part only (YYYY-MM-DD).
  Map<String, dynamic> toMapForDb() {
    return {
      'id': id,
      'date': date.toIso8601String().substring(0, 10), // For UNIQUE constraint
      'type': type.name,
      'cashAmount': cashAmount,
      'note': note,
      'createdAt': createdAt.toIso8601String(),
    };
  }

  DrawerSnapshot copyWith({
    int? id,
    DateTime? date,
    SnapshotType? type,
    double? cashAmount,
    String? note,
    DateTime? createdAt,
  }) {
    return DrawerSnapshot(
      id: id ?? this.id,
      date: date ?? this.date,
      type: type ?? this.type,
      cashAmount: cashAmount ?? this.cashAmount,
      note: note ?? this.note,
      createdAt: createdAt ?? this.createdAt,
    );
  }
}
// lib/data/models/category.dart
class Category {
  final int? id;
  final String name;
  final int iconCodePoint; // Ù„ØªØ®Ø²ÙŠÙ† Ø±Ù…Ø² Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø©
  final String type; // 'expense' or 'income'

  Category({
    this.id,
    required this.name,
    required this.iconCodePoint,
    required this.type,
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'name': name,
      'iconCodePoint': iconCodePoint,
      'type': type,
    };
  }

  factory Category.fromMap(Map<String, dynamic> map) {
    return Category(
      id: map['id'],
      name: map['name'],
      iconCodePoint: map['iconCodePoint'],
      type: map['type'],
    );
  }

  /// Ù…Ù‚Ø§Ø±Ù†Ø© Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ ÙˆÙ„ÙŠØ³ Ø§Ù„Ù…Ø±Ø¬Ø¹
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is Category &&
        other.id == id &&
        other.name == name &&
        other.iconCodePoint == iconCodePoint &&
        other.type == type;
  }

  /// Ø­Ø³Ø§Ø¨ hash code Ù„Ù„ÙƒØ§Ø¦Ù†
  @override
  int get hashCode {
    return id.hashCode ^ name.hashCode ^ iconCodePoint.hashCode ^ type.hashCode;
  }

  /// ØªÙ…Ø«ÙŠÙ„ Ù†ØµÙŠ Ù„Ù„ÙƒØ§Ø¦Ù† Ù„Ù„ØªØµØ­ÙŠØ­
  @override
  String toString() {
    return 'Category(id: $id, name: $name, iconCodePoint: $iconCodePoint, type: $type)';
  }

  Category copyWith({int? id, String? name, int? iconCodePoint, String? type}) {
    return Category(
      id: id ?? this.id,
      name: name ?? this.name,
      iconCodePoint: iconCodePoint ?? this.iconCodePoint,
      type: type ?? this.type,
    );
  }
}
// lib/data/models/debt_entry.dart
class DebtEntry {
  final int? id;
  final DateTime date;
  final int partyId;
  final String kind; // 'purchase_credit', 'payment', 'loan_out', 'settlement'
  final double amount;
  final String? note;
  final DateTime createdAt;

  DebtEntry({
    this.id,
    required this.date,
    required this.partyId,
    required this.kind,
    required this.amount,
    this.note,
    required this.createdAt,
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'date': date.toIso8601String(),
      'partyId': partyId,
      'kind': kind,
      'amount': amount,
      'note': note,
      'createdAt': createdAt.toIso8601String(),
    };
  }

  factory DebtEntry.fromMap(Map<String, dynamic> map) {
    return DebtEntry(
      id: map['id'] as int?,
      date: DateTime.parse(map['date'] as String),
      partyId: map['partyId'] as int,
      kind: map['kind'] as String,
      amount: (map['amount'] as num).toDouble(),
      note: map['note'] as String?,
      createdAt: DateTime.parse(map['createdAt'] as String),
    );
  }

  DebtEntry copyWith({
    int? id,
    DateTime? date,
    int? partyId,
    String? kind,
    double? amount,
    String? note,
    DateTime? createdAt,
  }) {
    return DebtEntry(
      id: id ?? this.id,
      date: date ?? this.date,
      partyId: partyId ?? this.partyId,
      kind: kind ?? this.kind,
      amount: amount ?? this.amount,
      note: note ?? this.note,
      createdAt: createdAt ?? this.createdAt,
    );
  }
}
// lib/data/local/database_helper.dart
import 'package:flutter/material.dart';
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';
import 'package:youssef_fabric_ledger/core/enums.dart';
import 'package:youssef_fabric_ledger/data/models/category.dart';
import 'package:youssef_fabric_ledger/data/models/debt_entry.dart';
import 'package:youssef_fabric_ledger/data/models/drawer_snapshot.dart';
import 'package:youssef_fabric_ledger/data/models/expense.dart';
import 'package:youssef_fabric_ledger/data/models/income.dart';
import 'package:youssef_fabric_ledger/data/models/party.dart';

class DatabaseHelper {
  static final DatabaseHelper instance = DatabaseHelper._init();
  static Database? _database;

  DatabaseHelper._init();

  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDB('youssef_ledger.db');
    return _database!;
  }

  Future<Database> _initDB(String filePath) async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, filePath);
    return await openDatabase(
      path,
      version: 4, // <-- Incremented version
      onCreate: _createDB,
      onUpgrade: _onUpgrade,
    );
  }

  Future _createDB(Database db, int version) async {
    await db.execute('''
      CREATE TABLE settings (key TEXT PRIMARY KEY, value TEXT NOT NULL)
    ''');
    await db.insert('settings', {'key': 'totalCashBalance', 'value': '0.0'});

    await db.execute('''
      CREATE TABLE expenses (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        date TEXT NOT NULL,
        amount REAL NOT NULL,
        categoryId INTEGER NOT NULL,
        source TEXT NOT NULL CHECK(source IN ('cash', 'drawer', 'bank')),
        note TEXT,
        createdAt TEXT NOT NULL
      )
    ''');

    await db.execute('''
      CREATE TABLE categories (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        iconCodePoint INTEGER NOT NULL,
        type TEXT NOT NULL CHECK(type IN ('expense', 'income'))
      )
    ''');

    await db.execute('''
      CREATE TABLE income (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        date TEXT NOT NULL,
        amount REAL NOT NULL,
        source TEXT NOT NULL CHECK(source IN ('cash', 'drawer', 'bank')), // <-- Added 'cash'
        note TEXT,
        createdAt TEXT NOT NULL
      )
    ''');

    await db.execute('''
      CREATE TABLE parties (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        type TEXT NOT NULL CHECK (type IN ('person','vendor')),
        phone TEXT
      )
    ''');

    await db.execute('''
      CREATE TABLE debt_entries (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        date TEXT NOT NULL,
        partyId INTEGER NOT NULL,
        kind TEXT NOT NULL,
        amount REAL NOT NULL,
        note TEXT,
        createdAt TEXT NOT NULL,
        FOREIGN KEY (partyId) REFERENCES parties (id) ON DELETE CASCADE
      )
    ''');

    await db.execute('''
      CREATE TABLE drawer_snapshots (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        date TEXT NOT NULL,
        type TEXT NOT NULL CHECK(type IN ('start', 'end')),
        cashAmount REAL NOT NULL,
        note TEXT,
        createdAt TEXT NOT NULL,
        UNIQUE(date, type)
      )
    ''');

    await _insertDefaultCategories(db);
  }

  Future _onUpgrade(Database db, int oldVersion, int newVersion) async {
    if (oldVersion < 2) {
      // Migrations for version 2 if any
    }
    if (oldVersion < 3) {
      await db.execute('''
      CREATE TABLE IF NOT EXISTS drawer_snapshots (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        date TEXT NOT NULL,
        type TEXT NOT NULL CHECK(type IN ('start', 'end')),
        cashAmount REAL NOT NULL,
        note TEXT,
        createdAt TEXT NOT NULL,
        UNIQUE(date, type)
        )
      ''');
    }
    if (oldVersion < 4) {
      // Add 'cash' to the CHECK constraint of the income table
      // SQLite doesn't support ALTER TABLE to modify a CHECK constraint directly.
      // The common workaround is to create a new table, copy data, and rename.
      await db.execute('PRAGMA foreign_keys=off;');
      await db.transaction((txn) async {
        await txn.execute('''
          CREATE TABLE income_new (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            date TEXT NOT NULL,
            amount REAL NOT NULL,
            source TEXT NOT NULL CHECK(source IN ('cash', 'drawer', 'bank')),
            note TEXT,
            createdAt TEXT NOT NULL
          )
        ''');
        await txn.execute(
          'INSERT INTO income_new(id, date, amount, source, note, createdAt) SELECT id, date, amount, source, note, createdAt FROM income;',
        );
        await txn.execute('DROP TABLE income;');
        await txn.execute('ALTER TABLE income_new RENAME TO income;');
      });
      await db.execute('PRAGMA foreign_keys=on;');

      // Create indexes for performance
      await db.execute(
        'CREATE INDEX IF NOT EXISTS idx_expenses_date ON expenses(date);',
      );
      await db.execute(
        'CREATE INDEX IF NOT EXISTS idx_expenses_source ON expenses(source);',
      );
      await db.execute(
        'CREATE INDEX IF NOT EXISTS idx_income_date ON income(date);',
      );
      await db.execute(
        'CREATE INDEX IF NOT EXISTS idx_income_source ON income(source);',
      );
      await db.execute(
        'CREATE INDEX IF NOT EXISTS idx_drawer_snapshots_date_type ON drawer_snapshots(date, type);',
      );
      await db.execute(
        'CREATE INDEX IF NOT EXISTS idx_debt_entries_partyId ON debt_entries(partyId);',
      );
    }
  }

  // --- CRUD for Parties ---
  Future<Party> createParty(Party party) async {
    final db = await instance.database;
    final id = await db.insert('parties', party.toMap());
    return party.copyWith(id: id);
  }

  Future<List<Party>> getParties(String type) async {
    final db = await instance.database;
    final maps = await db.query(
      'parties',
      where: 'type = ?',
      whereArgs: [type],
    );
    return List.generate(maps.length, (i) => Party.fromMap(maps[i]));
  }

  // --- CRUD for Debt Entries ---
  Future<DebtEntry> createDebtEntry(DebtEntry debtEntry) async {
    final db = await instance.database;
    final id = await db.insert('debt_entries', debtEntry.toMap());
    return debtEntry.copyWith(id: id);
  }

  Future<double> getPartyBalance(int partyId) async {
    final db = await instance.database;
    final entries = await db.query(
      'debt_entries',
      where: 'partyId = ?',
      whereArgs: [partyId],
    );
    double balance = 0.0;
    for (var entry in entries) {
      final kind = entry['kind'] as String;
      final amount = entry['amount'] as double;
      if (kind == 'purchase_credit' || kind == 'loan_out') {
        balance += amount;
      } else if (kind == 'payment' || kind == 'settlement') {
        balance -= amount;
      }
    }
    return balance;
  }

  Future<List<DebtEntry>> getDebtEntriesForParty(int partyId) async {
    final db = await instance.database;
    final maps = await db.query(
      'debt_entries',
      where: 'partyId = ?',
      whereArgs: [partyId],
      orderBy: 'date DESC',
    );
    return List.generate(maps.length, (i) => DebtEntry.fromMap(maps[i]));
  }

  // --- CRUD for Categories ---
  Future<Category> createCategory(Category category) async {
    final db = await instance.database;
    final id = await db.insert('categories', category.toMap());
    return category.copyWith(id: id);
  }

  Future<List<Category>> getCategories(String type) async {
    final db = await instance.database;
    final maps = await db.query(
      'categories',
      where: 'type = ?',
      whereArgs: [type],
      orderBy: 'name',
    );
    return List.generate(maps.length, (i) => Category.fromMap(maps[i]));
  }

  Future<Category?> getCategoryById(int id) async {
    final db = await instance.database;
    final maps = await db.query('categories', where: 'id = ?', whereArgs: [id]);
    if (maps.isNotEmpty) {
      return Category.fromMap(maps.first);
    }
    return null;
  }

  Future<int> updateCategory(Category category) async {
    final db = await instance.database;
    return db.update(
      'categories',
      category.toMap(),
      where: 'id = ?',
      whereArgs: [category.id],
    );
  }

  Future<int> deleteCategory(int id) async {
    final db = await instance.database;
    return db.delete('categories', where: 'id = ?', whereArgs: [id]);
  }

  // --- CRUD for Expenses ---
  Future<Expense> createExpense(Expense expense) async {
    final db = await instance.database;
    final id = await db.insert('expenses', expense.toMap());
    return expense.copyWith(id: id);
  }

  Future<List<Expense>> getExpensesForDate(DateTime date) async {
    final db = await instance.database;
    final dateStart = DateTime(
      date.year,
      date.month,
      date.day,
    ).toIso8601String();
    final dateEnd = DateTime(
      date.year,
      date.month,
      date.day + 1,
    ).toIso8601String();
    final maps = await db.query(
      'expenses',
      where: 'date >= ? AND date < ?',
      whereArgs: [dateStart, dateEnd],
      orderBy: 'createdAt DESC',
    );
    return List.generate(maps.length, (i) => Expense.fromMap(maps[i]));
  }

  Future<List<Expense>> getExpensesForDateRange(
    DateTime startDate,
    DateTime endDate,
  ) async {
    final db = await instance.database;
    final maps = await db.query(
      'expenses',
      where: 'date >= ? AND date < ?',
      whereArgs: [startDate.toIso8601String(), endDate.toIso8601String()],
      orderBy: 'date DESC',
    );
    return List.generate(maps.length, (i) => Expense.fromMap(maps[i]));
  }

  Future<int> updateExpense(Expense expense) async {
    final db = await instance.database;
    return db.update(
      'expenses',
      expense.toMap(),
      where: 'id = ?',
      whereArgs: [expense.id],
    );
  }

  Future<int> deleteExpense(int id) async {
    final db = await instance.database;
    return db.delete('expenses', where: 'id = ?', whereArgs: [id]);
  }

  // --- CRUD for Income ---
  Future<Income> createIncome(Income income) async {
    final db = await instance.database;
    final id = await db.insert('income', income.toMap());
    return income.copyWith(id: id);
  }

  Future<List<Income>> getIncomeForDate(DateTime date) async {
    final db = await instance.database;
    final dateStart = DateTime(
      date.year,
      date.month,
      date.day,
    ).toIso8601String();
    final dateEnd = DateTime(
      date.year,
      date.month,
      date.day + 1,
    ).toIso8601String();
    final maps = await db.query(
      'income',
      where: 'date >= ? AND date < ?',
      whereArgs: [dateStart, dateEnd],
      orderBy: 'createdAt DESC',
    );
    return List.generate(maps.length, (i) => Income.fromMap(maps[i]));
  }

  Future<List<Income>> getIncomeForDateRange(
    DateTime startDate,
    DateTime endDate,
  ) async {
    final db = await instance.database;
    final maps = await db.query(
      'income',
      where: 'date >= ? AND date < ?',
      whereArgs: [startDate.toIso8601String(), endDate.toIso8601String()],
      orderBy: 'date DESC',
    );
    return List.generate(maps.length, (i) => Income.fromMap(maps[i]));
  }

  Future<List<DrawerSnapshot>> getAllDrawerSnapshots() async {
    final db = await instance.database;
    final maps = await db.query('drawer_snapshots', orderBy: 'date DESC');
    return List.generate(maps.length, (i) => DrawerSnapshot.fromMap(maps[i]));
  }

  Future<int> deleteDrawerSnapshot(int id) async {
    final db = await instance.database;
    return db.delete('drawer_snapshots', where: 'id = ?', whereArgs: [id]);
  }

  // --- Drawer Snapshot ---
  Future<DrawerSnapshot> saveDrawerSnapshot(DrawerSnapshot snapshot) async {
    final db = await instance.database;
    // The toMapForDb method now handles the date string conversion
    final data = snapshot.toMapForDb();
    final id = await db.insert(
      'drawer_snapshots',
      data,
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
    return snapshot.copyWith(id: id);
  }

  Future<DrawerSnapshot?> getSnapshotForDate(
    DateTime date,
    SnapshotType type,
  ) async {
    final db = await instance.database;
    final dateString = date.toIso8601String().substring(0, 10);
    final maps = await db.query(
      'drawer_snapshots',
      where: 'date = ? AND type = ?',
      whereArgs: [dateString, type.name], // <-- Use enum's name
      limit: 1,
    );
    if (maps.isNotEmpty) {
      return DrawerSnapshot.fromMap(maps.first);
    }
    return null;
  }

  Future<DrawerSnapshot?> getLatestEndSnapshotBefore(DateTime date) async {
    final db = await instance.database;
    final dateString = date.toIso8601String().substring(0, 10);
    final maps = await db.query(
      'drawer_snapshots',
      where: 'type = ? AND date < ?',
      whereArgs: [SnapshotType.end.name, dateString], // <-- Use enum's name
      orderBy: 'date DESC',
      limit: 1,
    );
    if (maps.isNotEmpty) {
      return DrawerSnapshot.fromMap(maps.first);
    }
    return null;
  }

  Future<double> getDrawerExpensesForDate(DateTime date) async {
    final db = await instance.database;
    final dateString = date.toIso8601String().substring(0, 10);
    final result = await db.rawQuery(
      'SELECT SUM(amount) as total FROM expenses WHERE date LIKE ? AND source = ?',
      ['$dateString%', TransactionSource.drawer.name], // <-- Use enum's name
    );
    return (result.first['total'] as num?)?.toDouble() ?? 0.0;
  }

  Future<double> getDrawerIncomesForDate(DateTime date) async {
    final db = await instance.database;
    final dateString = date.toIso8601String().substring(0, 10);
    final result = await db.rawQuery(
      'SELECT SUM(amount) as total FROM income WHERE date LIKE ? AND source = ?',
      ['$dateString%', TransactionSource.drawer.name], // <-- Use enum's name
    );
    return (result.first['total'] as num?)?.toDouble() ?? 0.0;
  }

  // --- Settings ---
  Future<void> saveSetting(String key, String value) async {
    final db = await instance.database;
    await db.insert('settings', {
      'key': key,
      'value': value,
    }, conflictAlgorithm: ConflictAlgorithm.replace);
  }

  Future<String?> getSetting(String key) async {
    final db = await instance.database;
    final maps = await db.query('settings', where: 'key = ?', whereArgs: [key]);
    if (maps.isNotEmpty) {
      return maps.first['value'] as String?;
    }
    return null;
  }

  // --- Default Data ---
  Future<void> _insertDefaultCategories(Database db) async {
    final categories = [
      {'name': 'Ù…ÙˆØ§ØµÙ„Ø§Øª', 'icon': Icons.directions_bus, 'type': 'expense'},
      {'name': 'Ø·Ø¹Ø§Ù…', 'icon': Icons.restaurant, 'type': 'expense'},
      {'name': 'ØªØ³ÙˆÙ‚', 'icon': Icons.shopping_bag, 'type': 'expense'},
      {'name': 'Ù…Ù†Ø²Ù„', 'icon': Icons.home, 'type': 'expense'},
      {'name': 'ØµØ­Ø©', 'icon': Icons.health_and_safety, 'type': 'expense'},
      {'name': 'ÙÙˆØ§ØªÙŠØ±', 'icon': Icons.receipt_long, 'type': 'expense'},
    ];
    for (var cat in categories) {
      await db.insert('categories', {
        'name': cat['name'] as String,
        'iconCodePoint': (cat['icon'] as IconData).codePoint,
        'type': cat['type'] as String,
      }, conflictAlgorithm: ConflictAlgorithm.ignore);
    }
  }
}
// lib/presentation/screens/debts_screen.dart
import 'package:flutter/material.dart';
import 'package:youssef_fabric_ledger/data/local/database_helper.dart';
import 'package:youssef_fabric_ledger/data/models/party.dart';
import 'package:youssef_fabric_ledger/presentation/screens/party_details_screen.dart';
import '../theme/action_button_styles.dart';
import '../widgets/debt_transaction_modal.dart';
import '../widgets/parties_list_view.dart'; // Ø³Ù†Ù‚ÙˆÙ… Ø¨Ù†Ù‚Ù„ PartiesListView Ø¥Ù„Ù‰ Ù…Ù„ÙÙ‡ Ø§Ù„Ø®Ø§Øµ

class DebtsScreen extends StatefulWidget {
  const DebtsScreen({super.key});

  @override
  State<DebtsScreen> createState() => _DebtsScreenState();
}

class _DebtsScreenState extends State<DebtsScreen> {
  String _selectedPartyType = 'vendor';

  // --- âœ… Ù…ÙØªØ§Ø­ Ù„Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø­Ø§Ù„Ø© PartiesListView ÙˆØªØ­Ø¯ÙŠØ«Ù‡Ø§ ---
  final GlobalKey<_PartiesListViewState> _partiesListKey = GlobalKey();

  // --- âœ… Ø¯Ø§Ù„Ø© Ù„ÙØªØ­ Ù†Ø§ÙØ°Ø© Ø¥Ø¶Ø§ÙØ© Ø·Ø±Ù Ø¬Ø¯ÙŠØ¯ ---
  void _showAddPartyDialog() async {
    final nameController = TextEditingController();
    final newPartyName = await showDialog<String>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(
          'Ø¥Ø¶Ø§ÙØ© ${_selectedPartyType == 'vendor' ? 'Ù…ÙˆØ±Ø¯' : 'Ø´Ø®Øµ'} Ø¬Ø¯ÙŠØ¯',
        ),
        content: TextField(
          controller: nameController,
          decoration: const InputDecoration(hintText: "Ø§Ù„Ø§Ø³Ù…"),
          autofocus: true,
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Ø¥Ù„ØºØ§Ø¡'),
          ),
          FilledButton(
            onPressed: () => Navigator.of(context).pop(nameController.text),
            child: const Text('Ø¥Ø¶Ø§ÙØ©'),
          ),
        ],
      ),
    );

    if (newPartyName != null && newPartyName.isNotEmpty) {
      final newParty = Party(name: newPartyName, type: _selectedPartyType);
      await DatabaseHelper.instance.createParty(newParty);
      // --- âœ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø¥Ø¶Ø§ÙØ© ---
      _partiesListKey.currentState?.refreshData();
    }
  }

  @override
  Widget build(BuildContext context) {
    return Directionality(
      textDirection: TextDirection.rtl,
      child: Scaffold(
        appBar: AppBar(title: const Text('Ø§Ù„Ø¯ÙŠÙˆÙ†')),
        // --- âœ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Stack Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø²Ø± ÙÙˆÙ‚ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© ---
        body: Stack(
          children: [
            Column(
              children: [
                Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: _buildCustomToggleButtons(context),
                ),
                Expanded(
                  child: AnimatedSwitcher(
                    duration: const Duration(milliseconds: 250),
                    child: PartiesListView(
                      key: _partiesListKey, // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…ÙØªØ§Ø­ Ù‡Ù†Ø§
                      partyType: _selectedPartyType,
                    ),
                  ),
                ),
                const SizedBox(height: 80), // Ù…Ø³Ø§Ø­Ø© ÙØ§Ø±ØºØ© ÙÙŠ Ø§Ù„Ø£Ø³ÙÙ„ Ù„Ù„Ø²Ø±
              ],
            ),
            // --- âœ… Ø§Ù„Ø²Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ø§Ù„Ù…Ø®ØµØµ ---
            Positioned(
              bottom: 16,
              left: 16,
              right: 16,
              child: FloatingActionButton.extended(
                onPressed: _showAddPartyDialog,
                label: Text(
                  _selectedPartyType == 'vendor' ? 'Ø¥Ø¶Ø§ÙØ© Ù…ÙˆØ±Ø¯' : 'Ø¥Ø¶Ø§ÙØ© Ø´Ø®Øµ',
                  style: const TextStyle(fontWeight: FontWeight.bold),
                ),
                icon: const Icon(Icons.add),
              ),
            ),
          ],
        ),
      ),
    );
  }

  // --- Ø¯Ø§Ù„Ø© Ù„Ø¨Ù†Ø§Ø¡ Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ø¨Ø§Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„Ù…Ø®ØµØµ ---
  Widget _buildCustomToggleButtons(BuildContext context) {
    final bool isVendorSelected = _selectedPartyType == 'vendor';

    return Container(
      height: 50,
      decoration: BoxDecoration(
        color: Colors.grey.shade200,
        borderRadius: BorderRadius.circular(
          25.0,
        ), // Ù†ØµÙ Ø§Ù„Ø§Ø±ØªÙØ§Ø¹ Ù„Ø¬Ø¹Ù„Ù‡ Ø¨ÙŠØ¶Ø§ÙˆÙŠÙ‹Ø§
      ),
      child: Stack(
        children: [
          // --- Ø®Ù„ÙÙŠØ© Ø§Ù„Ø²Ø± Ø§Ù„Ù†Ø´Ø· Ø§Ù„Ù…ØªØ­Ø±ÙƒØ© ---
          AnimatedAlign(
            alignment: isVendorSelected
                ? Alignment.centerRight
                : Alignment.centerLeft,
            duration: const Duration(milliseconds: 250),
            curve: Curves.easeInOut,
            child: Container(
              width:
                  (MediaQuery.of(context).size.width - 32) /
                  2, // Ù†ØµÙ Ø¹Ø±Ø¶ Ø§Ù„Ø­Ø§ÙˆÙŠØ©
              height: 50,
              decoration: BoxDecoration(
                color: Theme.of(context).primaryColor,
                borderRadius: BorderRadius.circular(25.0),
              ),
            ),
          ),

          // --- Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„ÙØ¹Ù„ÙŠØ© (Ø´ÙØ§ÙØ©) ---
          Row(
            children: [
              _buildToggleButton(
                context,
                title: 'Ø§Ù„Ù…ÙˆØ±Ø¯ÙŠÙ†',
                icon: 'ğŸª', // Ø£ÙŠÙ‚ÙˆÙ†Ø© Ù…ØªØ¬Ø±
                isSelected: isVendorSelected,
                onTap: () {
                  setState(() {
                    _selectedPartyType = 'vendor';
                  });
                },
              ),
              _buildToggleButton(
                context,
                title: 'Ø§Ù„Ø£Ø´Ø®Ø§Øµ',
                icon: 'ğŸ§‘â€ğŸ¦±', // Ø£ÙŠÙ‚ÙˆÙ†Ø© Ø´Ø®Øµ
                isSelected: !isVendorSelected,
                onTap: () {
                  setState(() {
                    _selectedPartyType = 'person';
                  });
                },
              ),
            ],
          ),
        ],
      ),
    );
  }

  // --- ÙˆÙŠØ¯Ø¬Øª Ù…Ø³Ø§Ø¹Ø¯ Ù„Ø¨Ù†Ø§Ø¡ ÙƒÙ„ Ø²Ø± Ø¹Ù„Ù‰ Ø­Ø¯Ø© ---
  Widget _buildToggleButton(
    BuildContext context, {
    required String title,
    required String icon,
    required bool isSelected,
    required VoidCallback onTap,
  }) {
    return Expanded(
      child: GestureDetector(
        onTap: onTap,
        child: Container(
          color: Colors.transparent, // Ø§Ù„Ø²Ø± Ù†ÙØ³Ù‡ Ø´ÙØ§Ù Ù„ÙŠØ±Ù‰ Ø§Ù„Ø®Ù„ÙÙŠØ© Ø§Ù„Ù…ØªØ­Ø±ÙƒØ©
          child: Center(
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Text(
                  icon,
                  style: const TextStyle(fontSize: 20),
                ), // Ø§Ø³ØªØ®Ø¯Ø§Ù… Text Ù„Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø§Øª Ø§Ù„Ø±Ù…Ø²ÙŠØ©
                const SizedBox(width: 8),
                Text(
                  title,
                  style: TextStyle(
                    color: isSelected ? Colors.white : Colors.black87,
                    fontWeight: FontWeight.bold,
                    fontFamily: 'Tajawal',
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

/// ÙˆÙŠØ¯Ø¬Øª Ù„Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø·Ø±Ø§Ù Ù…Ø¹ Ø£Ø±ØµØ¯ØªÙ‡Ù…
class PartiesListView extends StatefulWidget {
  final String partyType;

  const PartiesListView({super.key, required this.partyType});

  @override
  State<PartiesListView> createState() => _PartiesListViewState();
}

class _PartiesListViewState extends State<PartiesListView> {
  List<Party> parties = [];
  Map<int, double> balances = {};
  bool isLoading = true;

  @override
  void initState() {
    super.initState();
    _loadPartiesAndBalances();
  }

  /// ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (ÙŠØ³ØªØ¯Ø¹Ù‰ Ù…Ù† Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠØ©)
  void refreshData() {
    _loadPartiesAndBalances();
  }

  /// ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ø·Ø±Ø§Ù ÙˆØ­Ø³Ø§Ø¨ Ø£Ø±ØµØ¯ØªÙ‡Ù…
  Future<void> _loadPartiesAndBalances() async {
    try {
      final loadedParties = await DatabaseHelper.instance.getParties(
        widget.partyType,
      );
      final Map<int, double> loadedBalances = {};

      for (Party party in loadedParties) {
        final balance = await DatabaseHelper.instance.getPartyBalance(
          party.id!,
        );
        loadedBalances[party.id!] = balance;
      }

      setState(() {
        parties = loadedParties;
        balances = loadedBalances;
        isLoading = false;
      });
    } catch (e) {
      setState(() {
        isLoading = false;
      });
      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text('Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: $e')));
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    if (isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    if (parties.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              widget.partyType == 'vendor' ? Icons.store : Icons.person,
              size: 64,
              color: Colors.grey,
            ),
            const SizedBox(height: 16),
            Text(
              'Ù„Ø§ ÙŠÙˆØ¬Ø¯ ${widget.partyType == 'vendor' ? 'Ù…ÙˆØ±Ø¯ÙŠÙ†' : 'Ø£Ø´Ø®Ø§Øµ'} Ø­Ø§Ù„ÙŠØ§Ù‹',
              style: Theme.of(
                context,
              ).textTheme.titleMedium?.copyWith(color: Colors.grey),
            ),
          ],
        ),
      );
    }

    return ListView.builder(
      padding: const EdgeInsets.symmetric(vertical: 8),
      itemCount: parties.length,
      itemBuilder: (context, index) {
        final party = parties[index];
        final balance = balances[party.id!] ?? 0.0;
        final isPositive = balance > 0;
        final isZero = balance == 0;

        // ØªØ³Ø¬ÙŠÙ„ Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ…
        print(
          'Party: ${party.name}, Type: ${party.type}, Widget Type: ${widget.partyType}',
        );

        return Card(
          margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
          child: Column(
            children: [
              ListTile(
                leading: CircleAvatar(
                  backgroundColor: isZero
                      ? Colors.grey
                      : isPositive
                      ? Colors.red.shade100
                      : Colors.green.shade100,
                  child: Icon(
                    widget.partyType == 'vendor' ? Icons.store : Icons.person,
                    color: isZero
                        ? Colors.grey.shade600
                        : isPositive
                        ? Colors.red.shade700
                        : Colors.green.shade700,
                  ),
                ),
                title: Text(
                  party.name,
                  style: const TextStyle(fontWeight: FontWeight.bold),
                ),
                subtitle: party.phone != null && party.phone!.isNotEmpty
                    ? Text(party.phone!)
                    : null,
                trailing: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  crossAxisAlignment: CrossAxisAlignment.end,
                  children: [
                    Text(
                      '${balance.abs().toStringAsFixed(2)} Ø¬.Ù…',
                      style: TextStyle(
                        fontWeight: FontWeight.bold,
                        fontSize: 16,
                        color: isZero
                            ? Colors.grey
                            : isPositive
                            ? Colors.red
                            : Colors.green,
                      ),
                    ),
                    Text(
                      isZero
                          ? 'Ù…ØªÙˆØ§Ø²Ù†'
                          : isPositive
                          ? (widget.partyType == 'vendor'
                                ? 'Ù…Ø³ØªØ­Ù‚ Ù„Ù‡'
                                : 'Ù…Ø³ØªØ­Ù‚ Ù…Ù†Ù‡')
                          : (widget.partyType == 'vendor'
                                ? 'Ù…Ø³ØªØ­Ù‚ Ù…Ù†Ù‡'
                                : 'Ù…Ø³ØªØ­Ù‚ Ù„Ù‡'),
                      style: TextStyle(
                        fontSize: 12,
                        color: Colors.grey.shade600,
                      ),
                    ),
                  ],
                ),
                onTap: () {
                  // Ø§Ù„ØªÙ†Ù‚Ù„ Ø¥Ù„Ù‰ ØµÙØ­Ø© ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø·Ø±Ù
                  Navigator.of(context).push(
                    MaterialPageRoute(
                      builder: (context) => PartyDetailsScreen(
                        party: party,
                        initialBalance: balance,
                      ),
                    ),
                  );
                },
              ),
              // Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø³ÙÙ„ÙŠØ© Ø­Ø³Ø¨ Ù†ÙˆØ¹ Ø§Ù„Ø·Ø±Ù
              Padding(
                padding: const EdgeInsets.fromLTRB(16, 0, 16, 12),
                child: Row(children: _getButtonsForParty(party)),
              ),
            ],
          ),
        );
      },
    );
  }

  /// ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø© Ø­Ø³Ø¨ Ù†ÙˆØ¹ Ø§Ù„Ø·Ø±Ù
  List<Widget> _getButtonsForParty(Party party) {
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù†ÙˆØ¹ Ø§Ù„Ø·Ø±Ù Ù…Ù† Ù†ÙˆØ¹ Ø§Ù„ØªØ¨ÙˆÙŠØ¨ Ø£ÙˆÙ„Ø§Ù‹ (Ù‡Ø°Ø§ Ù‡Ùˆ Ø§Ù„ØµØ­ÙŠØ­)
    final isVendor = widget.partyType == 'vendor';

    if (isVendor) {
      return [
        // Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù…ÙˆØ±Ø¯ÙŠÙ†: Ø´Ø±Ø§Ø¡ ÙˆØªØ³Ø¯ÙŠØ¯
        Expanded(
          child: FilledButton.icon(
            onPressed: () => _handlePurchaseAction(context, party),
            icon: const Icon(Icons.shopping_cart, size: 20),
            label: const Text('Ø´Ø±Ø§Ø¡'),
            style: ActionButtonStyles.redActionStyle.copyWith(
              minimumSize: WidgetStateProperty.all(const Size(0, 52)),
            ),
          ),
        ),
        const SizedBox(width: 12),
        Expanded(
          child: FilledButton.icon(
            onPressed: () => _handlePaymentAction(context, party),
            icon: const Icon(Icons.payment, size: 20),
            label: const Text('ØªØ³Ø¯ÙŠØ¯'),
            style: ActionButtonStyles.greenActionStyle.copyWith(
              minimumSize: WidgetStateProperty.all(const Size(0, 52)),
            ),
          ),
        ),
      ];
    } else {
      return [
        // Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø£Ø´Ø®Ø§Øµ: Ø¥Ù‚Ø±Ø§Ø¶ ÙˆØ§Ø³ØªÙ„Ø§Ù…
        Expanded(
          child: FilledButton.icon(
            onPressed: () => _handleLoanAction(context, party),
            icon: const Icon(Icons.arrow_upward, size: 20),
            label: const Text('Ø¥Ù‚Ø±Ø§Ø¶'),
            style: ActionButtonStyles.redActionStyle.copyWith(
              minimumSize: WidgetStateProperty.all(const Size(0, 52)),
            ),
          ),
        ),
        const SizedBox(width: 12),
        Expanded(
          child: FilledButton.icon(
            onPressed: () => _handleReceiveAction(context, party),
            icon: const Icon(Icons.arrow_downward, size: 20),
            label: const Text('Ø§Ø³ØªÙ„Ø§Ù…'),
            style: ActionButtonStyles.greenActionStyle.copyWith(
              minimumSize: WidgetStateProperty.all(const Size(0, 52)),
            ),
          ),
        ),
      ];
    }
  }

  /// Ù…Ø¹Ø§Ù„Ø¬ Ø²Ø± Ø§Ù„Ø´Ø±Ø§Ø¡ Ù„Ù„Ù…ÙˆØ±Ø¯ÙŠÙ†
  void _handlePurchaseAction(BuildContext context, Party party) {
    showDebtTransactionModal(
      context: context,
      party: party,
      transactionKind: 'purchase_credit',
      onTransactionSaved: refreshData,
    );
  }

  /// Ù…Ø¹Ø§Ù„Ø¬ Ø²Ø± Ø§Ù„ØªØ³Ø¯ÙŠØ¯ Ù„Ù„Ù…ÙˆØ±Ø¯ÙŠÙ†
  void _handlePaymentAction(BuildContext context, Party party) {
    showDebtTransactionModal(
      context: context,
      party: party,
      transactionKind: 'payment',
      onTransactionSaved: refreshData,
    );
  }

  /// Ù…Ø¹Ø§Ù„Ø¬ Ø²Ø± Ø§Ù„Ø¥Ù‚Ø±Ø§Ø¶ Ù„Ù„Ø£Ø´Ø®Ø§Øµ
  void _handleLoanAction(BuildContext context, Party party) {
    showDebtTransactionModal(
      context: context,
      party: party,
      transactionKind: 'loan_out',
      onTransactionSaved: refreshData,
    );
  }

  /// Ù…Ø¹Ø§Ù„Ø¬ Ø²Ø± Ø§Ù„Ø§Ø³ØªÙ„Ø§Ù… Ù„Ù„Ø£Ø´Ø®Ø§Øµ
  void _handleReceiveAction(BuildContext context, Party party) {
    showDebtTransactionModal(
      context: context,
      party: party,
      transactionKind: 'settlement',
      onTransactionSaved: refreshData,
    );
  }
}
// lib/presentation/screens/expenses_screen.dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart' hide TextDirection;
import 'package:collection/collection.dart';
import 'package:flutter_slidable/flutter_slidable.dart';
import 'package:youssef_fabric_ledger/data/local/database_helper.dart';
import 'package:youssef_fabric_ledger/data/models/expense.dart';
import 'package:youssef_fabric_ledger/data/models/category.dart';
import 'package:youssef_fabric_ledger/presentation/widgets/add_transaction_modal.dart';
import 'package:youssef_fabric_ledger/presentation/widgets/drawer_history_log.dart';
import 'package:youssef_fabric_ledger/core/enums.dart';

class ExpensesScreen extends StatefulWidget {
  const ExpensesScreen({Key? key}) : super(key: key);

  @override
  _ExpensesScreenState createState() => _ExpensesScreenState();
}

class _ExpensesScreenState extends State<ExpensesScreen> {
  // Ù…ØªØºÙŠØ± Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© ('expenses' or 'drawer')
  String _selectedView = 'expenses';

  @override
  Widget build(BuildContext context) {
    return Directionality(
      textDirection: TextDirection.rtl,
      child: Scaffold(
        appBar: AppBar(title: const Text('Ø§Ù„Ø³Ø¬Ù„Ø§Øª Ø§Ù„Ù…Ø§Ù„ÙŠØ©')),
        body: Column(
          children: [
            // --- Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ù‡Ù†Ø§ ---
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              child: SegmentedButton<String>(
                style: SegmentedButton.styleFrom(
                  backgroundColor: Colors.grey.shade200,
                  foregroundColor: Colors.grey.shade700,
                  selectedForegroundColor: Colors.white,
                  selectedBackgroundColor: Theme.of(context).primaryColor,
                  padding: const EdgeInsets.symmetric(vertical: 12),
                  textStyle: const TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                    fontFamily: 'Tajawal',
                  ),
                ),
                segments: const [
                  ButtonSegment(
                    value: 'expenses',
                    label: Text('Ø§Ù„Ù…ØµØ±ÙˆÙØ§Øª'),
                    icon: Icon(Icons.payment),
                  ),
                  ButtonSegment(
                    value: 'drawer',
                    label: Text('Ø§Ù„Ø¯Ø±Ø¬'),
                    icon: Icon(Icons.inbox),
                  ),
                ],
                selected: {_selectedView},
                onSelectionChanged: (newSelection) {
                  setState(() {
                    _selectedView = newSelection.first;
                  });
                },
              ),
            ),

            // --- Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø§Ù„Ù…Ø®ØªØ§Ø± ---
            Expanded(
              child: AnimatedSwitcher(
                duration: const Duration(milliseconds: 300),
                child: _selectedView == 'expenses'
                    ? const ExpensesListView() // Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ØµØ±ÙˆÙØ§Øª
                    : const DrawerHistoryLog(), // Ø¹Ù†ØµØ± Ù†Ø§Ø¦Ø¨ Ù„Ø³Ø¬Ù„ Ø§Ù„Ø¯Ø±Ø¬
              ),
            ),
          ],
        ),
      ),
    );
  }
}

// --- ÙØµÙ„Ù†Ø§ Ù…Ù†Ø·Ù‚ Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ØµØ±ÙˆÙØ§Øª ÙÙŠ ÙˆÙŠØ¯Ø¬Øª Ø®Ø§Øµ Ø¨Ù‡ ---
class ExpensesListView extends StatefulWidget {
  const ExpensesListView({super.key});

  @override
  _ExpensesListViewState createState() => _ExpensesListViewState();
}

class _ExpensesListViewState extends State<ExpensesListView> {
  late Future<List<Expense>> _expensesFuture;
  String _selectedTimeFilter =
      'all'; // 'all', 'today', 'week', 'month', 'custom'
  DateTime? _customStartDate;
  DateTime? _customEndDate;

  @override
  void initState() {
    super.initState();
    _loadExpenses();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    // Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ù†Ø¯ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø´Ø§Ø´Ø©
    _loadExpenses();
  }

  /// ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ØµØ±ÙˆÙØ§Øª Ø­Ø³Ø¨ Ø§Ù„ÙÙ„ØªØ± Ø§Ù„Ù…Ø­Ø¯Ø¯
  void _loadExpenses() {
    setState(() {
      _expensesFuture = _getFilteredExpenses();
    });
  }

  // --- âœ… Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ---
  void _refreshExpenses() {
    setState(() {
      _expensesFuture = _getFilteredExpenses();
    });
  }

  /// Ø¬Ù„Ø¨ Ø§Ù„Ù…ØµØ±ÙˆÙØ§Øª Ø§Ù„Ù…ÙÙ„ØªØ±Ø© Ø­Ø³Ø¨ Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ©
  Future<List<Expense>> _getFilteredExpenses() async {
    final now = DateTime.now();
    DateTime? startDate;
    DateTime? endDate;

    switch (_selectedTimeFilter) {
      case 'today':
        startDate = DateTime(now.year, now.month, now.day);
        endDate = DateTime(now.year, now.month, now.day + 1);
        break;
      case 'week':
        final weekStart = now.subtract(Duration(days: now.weekday - 1));
        startDate = DateTime(weekStart.year, weekStart.month, weekStart.day);
        endDate = DateTime(now.year, now.month, now.day + 1);
        break;
      case 'month':
        startDate = DateTime(now.year, now.month, 1);
        endDate = DateTime(now.year, now.month + 1, 1);
        break;
      case 'custom':
        if (_customStartDate != null && _customEndDate != null) {
          startDate = _customStartDate;
          endDate = DateTime(
            _customEndDate!.year,
            _customEndDate!.month,
            _customEndDate!.day + 1,
          );
        }
        break;
      default:
        return DatabaseHelper.instance.getExpensesForDateRange(
          DateTime(2000),
          DateTime.now().add(const Duration(days: 1)),
        );
    }

    if (startDate != null && endDate != null) {
      return DatabaseHelper.instance.getExpensesForDateRange(
        startDate,
        endDate,
      );
    }
    return DatabaseHelper.instance.getExpensesForDateRange(
      DateTime(2000),
      DateTime.now().add(const Duration(days: 1)),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        // ÙÙ„Ø§ØªØ± Ø§Ù„ÙˆÙ‚Øª
        Padding(
          padding: const EdgeInsets.all(16.0),
          child: _buildTimeFilters(context),
        ),
        // Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ØµØ±ÙˆÙØ§Øª
        Expanded(
          child: FutureBuilder<List<Expense>>(
            future: _expensesFuture,
            builder: (context, snapshot) {
              if (snapshot.connectionState == ConnectionState.waiting) {
                return const Center(child: CircularProgressIndicator());
              }
              if (!snapshot.hasData || snapshot.data!.isEmpty) {
                return const Center(
                  child: Text('Ù„Ù… ÙŠØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø£ÙŠ Ù…ØµØ±ÙˆÙØ§Øª Ø¨Ø¹Ø¯.'),
                );
              }

              final expenses = snapshot.data!;
              // Ø§Ø³ØªØ®Ø¯Ø§Ù… groupBy Ù„ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù…ØµØ±ÙˆÙØ§Øª Ø­Ø³Ø¨ Ø§Ù„ÙŠÙˆÙ…
              final groupedExpenses = groupBy(
                expenses,
                (Expense e) => DateFormat('yyyy-MM-dd').format(e.date),
              );

              return ListView.builder(
                itemCount: groupedExpenses.keys.length,
                itemBuilder: (context, index) {
                  final dateKey = groupedExpenses.keys.elementAt(index);
                  final expensesForDay = groupedExpenses[dateKey]!;
                  final date = DateTime.parse(dateKey);

                  return _buildDaySection(context, date, expensesForDay);
                },
              );
            },
          ),
        ),
      ],
    );
  }

  /// Ø¨Ù†Ø§Ø¡ ÙÙ„Ø§ØªØ± Ø§Ù„ÙˆÙ‚Øª
  Widget _buildTimeFilters(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).primaryColor,
        borderRadius: BorderRadius.circular(16),
      ),
      child: Column(
        children: [
          // Ø£Ø²Ø±Ø§Ø± Ø§Ù„ÙÙ„Ø§ØªØ± Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
          Row(
            children: [
              Expanded(
                child: _buildFilterButton(
                  context,
                  'Ø§Ù„ÙƒÙ„',
                  'all',
                  _selectedTimeFilter == 'all',
                ),
              ),
              const SizedBox(width: 8),
              Expanded(
                child: _buildFilterButton(
                  context,
                  'Ø§Ù„ÙŠÙˆÙ…',
                  'today',
                  _selectedTimeFilter == 'today',
                ),
              ),
              const SizedBox(width: 8),
              Expanded(
                child: _buildFilterButton(
                  context,
                  'Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹',
                  'week',
                  _selectedTimeFilter == 'week',
                ),
              ),
              const SizedBox(width: 8),
              Expanded(
                child: _buildFilterButton(
                  context,
                  'Ø§Ù„Ø´Ù‡Ø±',
                  'month',
                  _selectedTimeFilter == 'month',
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          // Ø²Ø± Ø§Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø®ØµØµ
          SizedBox(
            width: double.infinity,
            child: _buildFilterButton(
              context,
              _getCustomDateText(),
              'custom',
              _selectedTimeFilter == 'custom',
            ),
          ),
        ],
      ),
    );
  }

  /// Ø¨Ù†Ø§Ø¡ Ø²Ø± ÙÙ„ØªØ± ÙˆØ§Ø­Ø¯
  Widget _buildFilterButton(
    BuildContext context,
    String title,
    String value,
    bool isSelected,
  ) {
    return GestureDetector(
      onTap: () {
        if (value == 'custom') {
          _showCustomDatePicker(context);
        } else {
          setState(() {
            _selectedTimeFilter = value;
          });
          _loadExpenses();
        }
      },
      child: Container(
        padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
        decoration: BoxDecoration(
          color: isSelected ? Colors.white : Colors.white.withOpacity(0.2),
          borderRadius: BorderRadius.circular(12),
        ),
        child: Text(
          title,
          textAlign: TextAlign.center,
          style: TextStyle(
            color: isSelected ? Theme.of(context).primaryColor : Colors.white,
            fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
            fontSize: 14,
          ),
        ),
      ),
    );
  }

  /// Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù†Øµ Ø§Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø®ØµØµ
  String _getCustomDateText() {
    if (_customStartDate != null && _customEndDate != null) {
      final formatter = DateFormat('dd/MM/yyyy', 'ar');
      return '${formatter.format(_customStartDate!)} - ${formatter.format(_customEndDate!)}';
    }
    return 'ØªØ§Ø±ÙŠØ® Ù…Ø­Ø¯Ø¯';
  }

  /// Ø¹Ø±Ø¶ Ù…Ù†ØªÙ‚ÙŠ Ø§Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø®ØµØµ
  Future<void> _showCustomDatePicker(BuildContext context) async {
    final DateTimeRange? picked = await showDateRangePicker(
      context: context,
      firstDate: DateTime(2020),
      lastDate: DateTime.now(),
      initialDateRange: _customStartDate != null && _customEndDate != null
          ? DateTimeRange(start: _customStartDate!, end: _customEndDate!)
          : null,
      locale: const Locale('ar'),
    );

    if (picked != null) {
      setState(() {
        _customStartDate = picked.start;
        _customEndDate = picked.end;
        _selectedTimeFilter = 'custom';
      });
      _loadExpenses();
    }
  }

  // ÙˆÙŠØ¯Ø¬Øª Ù„Ø¹Ø±Ø¶ Ù‚Ø³Ù… Ø§Ù„ÙŠÙˆÙ… Ø§Ù„ÙˆØ§Ø­Ø¯
  Widget _buildDaySection(
    BuildContext context,
    DateTime date,
    List<Expense> expenses,
  ) {
    final total = expenses.fold<double>(0, (sum, item) => sum + item.amount);
    final currencyFormat = NumberFormat.currency(locale: 'ar', symbol: 'Ø¯.Ø¬');

    return Card(
      margin: const EdgeInsets.symmetric(vertical: 8),
      elevation: 1,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Column(
        children: [
          // Ø±Ø£Ø³ Ø§Ù„ÙŠÙˆÙ…
          Padding(
            padding: const EdgeInsets.all(12.0),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  DateFormat.yMMMMEEEEd('ar').format(date),
                  style: const TextStyle(
                    fontWeight: FontWeight.bold,
                    fontSize: 16,
                  ),
                ),
                Text(
                  currencyFormat.format(total),
                  style: const TextStyle(
                    fontWeight: FontWeight.bold,
                    fontSize: 16,
                    color: Colors.red,
                  ),
                ),
              ],
            ),
          ),
          const Divider(height: 1),
          // Ù‚Ø§Ø¦Ù…Ø© Ù…ØµØ±ÙˆÙØ§Øª Ø§Ù„ÙŠÙˆÙ…
          ...expenses
              .map(
                (expense) => ExpenseItem(
                  expense: expense,
                  onUpdate: _refreshExpenses, // ØªÙ…Ø±ÙŠØ± Ø§Ù„Ø¯Ø§Ù„Ø©
                ),
              )
              .toList(),
        ],
      ),
    );
  }
}

// ÙˆÙŠØ¯Ø¬Øª Ù„Ø¹Ø±Ø¶ Ø¹Ù†ØµØ± Ø§Ù„Ù…ØµØ±ÙˆÙ Ø§Ù„ÙˆØ§Ø­Ø¯
class ExpenseItem extends StatelessWidget {
  final Expense expense;
  final VoidCallback onUpdate; // Ù„Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø¯Ø§Ù„Ø© Ø§Ù„ØªØ­Ø¯ÙŠØ«

  const ExpenseItem({required this.expense, required this.onUpdate, super.key});

  // Ø¯Ø§Ù„Ø© Ø§Ù„Ø­Ø°Ù
  Future<void> _delete(BuildContext context) async {
    await DatabaseHelper.instance.deleteExpense(expense.id!);
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…ØµØ±ÙˆÙ'),
        backgroundColor: Colors.red,
      ),
    );
    // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø¯Ø§Ù„Ø© Ø§Ù„ØªØ­Ø¯ÙŠØ« Ù„Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©
    onUpdate();
  }

  // --- âœ… ØªÙØ¹ÙŠÙ„ Ø¯Ø§Ù„Ø© Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ ---
  void _edit(BuildContext context) async {
    // Ø§ÙØªØ­ Ù†Ø§ÙØ°Ø© Ø§Ù„Ø¥Ø¶Ø§ÙØ©/Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ ÙˆÙ‚Ù… Ø¨ØªÙ…Ø±ÙŠØ± Ø§Ù„Ù…ØµØ±ÙˆÙ Ø§Ù„Ø­Ø§Ù„ÙŠ
    final result = await showModalBottomSheet<bool>(
      context: context,
      isScrollControlled: true,
      builder: (_) => AddTransactionModal(expenseToEdit: expense),
    );

    // Ø¥Ø°Ø§ ØªÙ… Ø§Ù„Ø­ÙØ¸ Ø¨Ù†Ø¬Ø§Ø­ (Ø£ÙØ±Ø¬Ø¹Øª true)ØŒ Ù‚Ù… Ø¨ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©
    if (result == true) {
      onUpdate();
    }
  }

  @override
  Widget build(BuildContext context) {
    final currencyFormat = NumberFormat.currency(locale: 'ar', symbol: 'Ø¯.Ø¬');

    return Slidable(
      key: ValueKey(expense.id),
      // --- Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªÙŠ ØªØ¸Ù‡Ø± Ø¹Ù„Ù‰ Ø§Ù„ÙŠØ³Ø§Ø± Ø¹Ù†Ø¯ Ø§Ù„Ø³Ø­Ø¨ ---
      startActionPane: ActionPane(
        motion: const DrawerMotion(),
        children: [
          SlidableAction(
            onPressed: (ctx) => _delete(context),
            backgroundColor: Colors.red,
            foregroundColor: Colors.white,
            icon: Icons.delete,
            label: 'Ø­Ø°Ù',
            borderRadius: BorderRadius.circular(12),
          ),
          SlidableAction(
            onPressed: _edit,
            backgroundColor: Colors.blue,
            foregroundColor: Colors.white,
            icon: Icons.edit,
            label: 'ØªØ¹Ø¯ÙŠÙ„',
            borderRadius: BorderRadius.circular(12),
          ),
        ],
      ),
      child: FutureBuilder<Category?>(
        future: DatabaseHelper.instance.getCategoryById(expense.categoryId),
        builder: (context, snapshot) {
          final categoryName = snapshot.hasData ? snapshot.data!.name : '...';
          final categoryIcon = snapshot.hasData
              ? IconData(
                  snapshot.data!.iconCodePoint,
                  fontFamily: 'MaterialIcons',
                )
              : Icons.label_outline;

          final sourceMap = {
            TransactionSource.cash.name: 'Ù…Ù† Ø§Ù„ÙƒØ§Ø´',
            TransactionSource.drawer.name: 'Ù…Ù† Ø§Ù„Ø¯Ø±Ø¬',
            TransactionSource.bank.name: 'Ù…Ù† Ø§Ù„Ø¨Ù†Ùƒ',
          };

          return ListTile(
            leading: CircleAvatar(child: Icon(categoryIcon, size: 20)),
            title: Text(categoryName),
            subtitle: Text(
              expense.note ??
                  'Ù…ØµØ¯Ø±Ù‡: ${sourceMap[expense.source.name] ?? expense.source.name}',
            ),
            trailing: Text(
              currencyFormat.format(expense.amount),
              style: const TextStyle(
                fontWeight: FontWeight.bold,
                color: Colors.black87,
              ),
            ),
          );
        },
      ),
    );
  }
}
// lib/presentation/screens/drawer_screen.dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:provider/provider.dart';
import 'package:youssef_fabric_ledger/core/enums.dart';
import 'package:youssef_fabric_ledger/logic/providers/date_provider.dart';
import 'package:youssef_fabric_ledger/logic/providers/finance_provider.dart';

class DrawerScreen extends StatefulWidget {
  const DrawerScreen({super.key});

  @override
  State<DrawerScreen> createState() => _DrawerScreenState();
}

class _DrawerScreenState extends State<DrawerScreen> {
  final _formKey = GlobalKey<FormState>();
  late TextEditingController _startBalanceController;
  late TextEditingController _endBalanceController;
  late FinanceProvider _financeProvider;
  late DateProvider _dateProvider;

  @override
  void initState() {
    super.initState();
    _financeProvider = Provider.of<FinanceProvider>(context, listen: false);
    _dateProvider = Provider.of<DateProvider>(context, listen: false);
    final startSnapshot = _financeProvider.drawerSnapshots['start'];
    final endSnapshot = _financeProvider.drawerSnapshots['end'];

    _startBalanceController = TextEditingController(
      text: startSnapshot?.cashAmount.toString() ?? '',
    );
    _endBalanceController = TextEditingController(
      text: endSnapshot?.cashAmount.toString() ?? '',
    );
  }

  @override
  void dispose() {
    _startBalanceController.dispose();
    _endBalanceController.dispose();
    super.dispose();
  }

  Future<void> _saveSnapshots() async {
    if (_formKey.currentState!.validate()) {
      final startAmount = double.tryParse(_startBalanceController.text) ?? 0.0;
      final endAmount = double.tryParse(_endBalanceController.text) ?? 0.0;
      final date = _dateProvider.selectedDate;

      // Save start balance
      await _financeProvider.saveDrawerSnapshot(
        date: date,
        type: SnapshotType.start,
        amount: startAmount,
      );

      // Save end balance
      await _financeProvider.saveDrawerSnapshot(
        date: date,
        type: SnapshotType.end,
        amount: endAmount,
      );

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('ØªÙ… Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯Ø±Ø¬ Ø¨Ù†Ø¬Ø§Ø­')),
        );
        Navigator.of(context).pop();
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(
          'Ø¥Ø¯Ø§Ø±Ø© Ø¯Ø±Ø¬ ÙŠÙˆÙ… ${DateFormat.yMMMd('ar').format(_dateProvider.selectedDate)}',
        ),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Form(
          key: _formKey,
          child: ListView(
            children: [
              _buildBalanceCard(),
              const SizedBox(height: 24),
              _buildSummaryCard(),
              const SizedBox(height: 32),
              ElevatedButton(
                onPressed: _saveSnapshots,
                child: const Text('Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª'),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildBalanceCard() {
    return Card(
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Ø£Ø±ØµØ¯Ø© Ø§Ù„Ø¯Ø±Ø¬', style: Theme.of(context).textTheme.titleLarge),
            const SizedBox(height: 16),
            TextFormField(
              controller: _startBalanceController,
              decoration: const InputDecoration(
                labelText: 'Ø±ØµÙŠØ¯ Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„ÙŠÙˆÙ…',
                prefixIcon: Icon(Icons.wb_sunny_outlined),
              ),
              keyboardType: TextInputType.number,
              validator: (value) {
                if (value == null || value.isEmpty) {
                  return 'ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±ØµÙŠØ¯ Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„ÙŠÙˆÙ…';
                }
                if (double.tryParse(value) == null) {
                  return 'ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­';
                }
                return null;
              },
            ),
            const SizedBox(height: 16),
            TextFormField(
              controller: _endBalanceController,
              decoration: const InputDecoration(
                labelText: 'Ø±ØµÙŠØ¯ Ù†Ù‡Ø§ÙŠØ© Ø§Ù„ÙŠÙˆÙ…',
                prefixIcon: Icon(Icons.nightlight_round),
              ),
              keyboardType: TextInputType.number,
              validator: (value) {
                if (value == null || value.isEmpty) {
                  return 'ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±ØµÙŠØ¯ Ù†Ù‡Ø§ÙŠØ© Ø§Ù„ÙŠÙˆÙ…';
                }
                if (double.tryParse(value) == null) {
                  return 'ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­';
                }
                return null;
              },
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSummaryCard() {
    return Consumer<FinanceProvider>(
      builder: (context, provider, child) {
        final turnover = provider.calculatedTurnover;
        final sales = provider.totalIncome;
        return Card(
          elevation: 2,
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Ù…Ù„Ø®Øµ Ø§Ù„ÙŠÙˆÙ…',
                  style: Theme.of(context).textTheme.titleLarge,
                ),
                const SizedBox(height: 16),
                ListTile(
                  leading: const Icon(Icons.sync_alt, color: Colors.blue),
                  title: const Text('Ø¯ÙˆØ±Ø© Ø±Ø£Ø³ Ø§Ù„Ù…Ø§Ù„ (Turnover)'),
                  trailing: Text(
                    NumberFormat.currency(
                      locale: 'ar_EG',
                      symbol: 'Ø¬.Ù…',
                    ).format(turnover),
                    style: const TextStyle(
                      fontWeight: FontWeight.bold,
                      fontSize: 16,
                    ),
                  ),
                ),
                ListTile(
                  leading: const Icon(Icons.point_of_sale, color: Colors.green),
                  title: const Text('Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø¯Ø®Ù„ (Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª)'),
                  trailing: Text(
                    NumberFormat.currency(
                      locale: 'ar_EG',
                      symbol: 'Ø¬.Ù…',
                    ).format(sales),
                    style: const TextStyle(
                      fontWeight: FontWeight.bold,
                      fontSize: 16,
                    ),
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}
// lib/presentation/screens/settings_screen.dart
import 'package:flutter/material.dart';
import 'package:youssef_fabric_ledger/presentation/screens/manage_categories_screen.dart';

class SettingsScreen extends StatelessWidget {
  const SettingsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Directionality(
      textDirection: TextDirection.rtl,
      child: Scaffold(
        appBar: AppBar(title: const Text('Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª')),
        body: ListView(
          children: [
            ListTile(
              leading: const Icon(Icons.category_outlined),
              title: const Text('Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ÙØ¦Ø§Øª'),
              subtitle: const Text('Ø¥Ø¶Ø§ÙØ© ÙˆØªØ¹Ø¯ÙŠÙ„ ÙØ¦Ø§Øª Ø§Ù„Ù…ØµØ±ÙˆÙØ§Øª ÙˆØ§Ù„Ø¯Ø®Ù„'),
              onTap: () {
                Navigator.of(context).push(
                  MaterialPageRoute(
                    builder: (context) => const ManageCategoriesScreen(),
                  ),
                );
              },
            ),
            // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù‡Ù†Ø§ Ù„Ø§Ø­Ù‚Ø§Ù‹
          ],
        ),
      ),
    );
  }
}
// lib/presentation/screens/manage_categories_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_iconpicker/flutter_iconpicker.dart';
import 'package:youssef_fabric_ledger/data/local/database_helper.dart';
import 'package:youssef_fabric_ledger/data/models/category.dart';

class ManageCategoriesScreen extends StatefulWidget {
  const ManageCategoriesScreen({super.key});

  @override
  ManageCategoriesScreenState createState() => ManageCategoriesScreenState();
}

class ManageCategoriesScreenState extends State<ManageCategoriesScreen> {
  late Future<List<Category>> _categoriesFuture;

  @override
  void initState() {
    super.initState();
    _loadCategories();
  }

  void _loadCategories() {
    setState(() {
      _categoriesFuture = DatabaseHelper.instance.getCategories('expense');
    });
  }

  @override
  Widget build(BuildContext context) {
    return Directionality(
      textDirection: TextDirection.rtl,
      child: Scaffold(
        appBar: AppBar(title: const Text('Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ÙØ¦Ø§Øª')),
        body: FutureBuilder<List<Category>>(
          future: _categoriesFuture,
          builder: (context, snapshot) {
            if (snapshot.connectionState == ConnectionState.waiting) {
              return const Center(child: CircularProgressIndicator());
            }
            if (!snapshot.hasData || snapshot.data!.isEmpty) {
              return const Center(
                child: Text('Ù„Ø§ ØªÙˆØ¬Ø¯ ÙØ¦Ø§Øª. Ù‚Ù… Ø¨Ø¥Ø¶Ø§ÙØ© ÙØ¦Ø© Ø¬Ø¯ÙŠØ¯Ø©.'),
              );
            }

            final categories = snapshot.data!;
            return ListView.builder(
              itemCount: categories.length,
              itemBuilder: (context, index) {
                final category = categories[index];
                return ListTile(
                  leading: Icon(
                    IconData(
                      category.iconCodePoint,
                      fontFamily: 'MaterialIcons',
                    ),
                  ),
                  title: Text(category.name),
                  trailing: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      IconButton(
                        icon: const Icon(Icons.edit_outlined),
                        onPressed: () =>
                            _showCategoryDialog(category: category),
                      ),
                      IconButton(
                        icon: const Icon(
                          Icons.delete_outline,
                          color: Colors.red,
                        ),
                        onPressed: () => _deleteCategory(category.id!),
                      ),
                    ],
                  ),
                );
              },
            );
          },
        ),
        floatingActionButton: FloatingActionButton(
          onPressed: () => _showCategoryDialog(),
          child: const Icon(Icons.add),
        ),
      ),
    );
  }

  void _showCategoryDialog({Category? category}) {
    final isEditing = category != null;
    final nameController = TextEditingController(text: category?.name);
    IconData? selectedIcon = isEditing
        ? IconData(category.iconCodePoint, fontFamily: 'MaterialIcons')
        : null;

    showDialog(
      context: context,
      builder: (context) {
        return StatefulBuilder(
          builder: (context, setDialogState) {
            return AlertDialog(
              title: Text(isEditing ? 'ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ÙØ¦Ø©' : 'ÙØ¦Ø© Ø¬Ø¯ÙŠØ¯Ø©'),
              content: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  TextField(
                    controller: nameController,
                    decoration: const InputDecoration(labelText: 'Ø§Ø³Ù… Ø§Ù„ÙØ¦Ø©'),
                    autofocus: true,
                  ),
                  const SizedBox(height: 20),
                  Row(
                    children: [
                      const Text("Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø©: "),
                      const Spacer(),
                      if (selectedIcon != null) Icon(selectedIcon),
                      const SizedBox(width: 10),
                      ElevatedButton(
                        child: const Text('Ø§Ø®ØªØ±'),
                        onPressed: () async {
                          final picked = await showIconPicker(context);
                          if (picked != null) {
                            setDialogState(() {
                              selectedIcon = picked.data; // IconData
                            });
                          }
                        },
                      ),
                    ],
                  ),
                ],
              ),
              actions: [
                TextButton(
                  child: const Text('Ø¥Ù„ØºØ§Ø¡'),
                  onPressed: () => Navigator.of(context).pop(),
                ),
                FilledButton(
                  child: const Text('Ø­ÙØ¸'),
                  onPressed: () async {
                    if (nameController.text.isEmpty) {
                      // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¸Ù‡Ø§Ø± Ø±Ø³Ø§Ù„Ø© Ø®Ø·Ø£ Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ø£Ø±Ø¯Øª
                      return;
                    }

                    // 2. Ø¥Ø°Ø§ Ù„Ù… ÙŠØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø£ÙŠÙ‚ÙˆÙ†Ø©ØŒ Ù‚Ù… Ø¨ØªØ¹ÙŠÙŠÙ† Ø£ÙŠÙ‚ÙˆÙ†Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
                    final finalIcon = selectedIcon ?? Icons.label_outline;

                    final newCategory = Category(
                      id: category?.id,
                      name: nameController.text,
                      iconCodePoint:
                          finalIcon.codePoint, // Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©
                      type: 'expense',
                    );

                    if (isEditing) {
                      await DatabaseHelper.instance.updateCategory(newCategory);
                    } else {
                      await DatabaseHelper.instance.createCategory(newCategory);
                    }

                    if (mounted) {
                      _loadCategories(); // Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©
                      Navigator.of(context).pop();
                    }
                  },
                ),
              ],
            );
          },
        );
      },
    );
  }

  void _deleteCategory(int id) async {
    // ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ù†Ø§ÙØ°Ø© ØªØ£ÙƒÙŠØ¯ Ù‡Ù†Ø§
    await DatabaseHelper.instance.deleteCategory(id);
    _loadCategories();
  }
}
// lib/presentation/screens/main_layout.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:youssef_fabric_ledger/presentation/screens/expenses_screen.dart';
import 'package:youssef_fabric_ledger/presentation/screens/home_screen.dart';
import 'package:youssef_fabric_ledger/presentation/screens/debts_screen.dart';
import 'package:youssef_fabric_ledger/presentation/widgets/add_transaction_modal.dart';
import 'package:youssef_fabric_ledger/logic/providers/finance_provider.dart';

class MainLayout extends StatefulWidget {
  const MainLayout({super.key});
  @override
  State<MainLayout> createState() => _MainLayoutState();
}

class _MainLayoutState extends State<MainLayout> {
  final PageController _pageController = PageController();
  int _currentIndex = 0;
  Key _expensesKey = UniqueKey(); // Ù…ÙØªØ§Ø­ ÙØ±ÙŠØ¯ Ù„Ø´Ø§Ø´Ø© Ø§Ù„Ù…ØµØ±ÙˆÙØ§Øª

  @override
  void dispose() {
    _pageController.dispose();
    super.dispose();
  }

  void _onTabTapped(int index) {
    setState(() {
      _currentIndex = index;
    });
    _pageController.jumpToPage(index);
  }

  /// Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„ØªÙŠ ØªÙØªØ­ Ø§Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ù…Ù†Ø¨Ø«Ù‚Ø© Ù…Ù† Ø§Ù„Ø£Ø³ÙÙ„ Ù„Ø¥Ø¶Ø§ÙØ© Ù…ØµØ±ÙˆÙ Ø¬Ø¯ÙŠØ¯
  void _showAddTransactionModal() async {
    // 1. Ø§Ù†ØªØ¸Ø± Ø§Ù„Ù†ØªÙŠØ¬Ø© Ù…Ù† Ø§Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ù…Ù†Ø¨Ø«Ù‚Ø©
    final result = await showModalBottomSheet<bool>(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.white,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (context) => AddTransactionModal(),
    );

    // 2. Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù†ØªÙŠØ¬Ø© 'true' (ÙŠØ¹Ù†ÙŠ ØªÙ… Ø§Ù„Ø­ÙØ¸ Ø¨Ù†Ø¬Ø§Ø­)ØŒ Ù‚Ù… Ø¨ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    if (result == true && mounted) {
      // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø¯Ø§Ù„Ø© Ø§Ù„ØªØ­Ø¯ÙŠØ« ÙÙŠ Ø§Ù„Ù€ Provider
      context.read<FinanceProvider>().refreshTodayData();
    }
  }

  @override
  Widget build(BuildContext context) {
    return Directionality(
      textDirection: TextDirection.rtl,
      child: Scaffold(
        body: PageView(
          controller: _pageController,
          onPageChanged: (index) {
            setState(() {
              _currentIndex = index;
            });
          },
          children: <Widget>[
            const HomeScreen(),
            ExpensesScreen(
              key: _expensesKey,
            ), // Expenses Screen with unique key
            const DebtsScreen(), // Debts Screen
            const Center(child: Text('Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ±')), // Reports Screen
          ],
        ),
        floatingActionButton: FloatingActionButton(
          onPressed: _showAddTransactionModal, // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„Ø¯Ø§Ù„Ø© Ù‡Ù†Ø§
          shape: const CircleBorder(),
          child: const Icon(Icons.add),
        ),
        floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
        bottomNavigationBar: BottomAppBar(
          shape: const CircularNotchedRectangle(),
          notchMargin: 8.0,
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceAround,
            children: <Widget>[
              _buildNavItem(Icons.home, 'Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©', 0),
              _buildNavItem(Icons.wallet, 'Ø§Ù„Ù…ØµØ±ÙˆÙØ§Øª', 1),
              const SizedBox(width: 48), // Spacer for the FAB
              _buildNavItem(Icons.people_alt, 'Ø§Ù„Ø¯ÙŠÙˆÙ†', 2),
              _buildNavItem(Icons.bar_chart, 'Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ±', 3),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildNavItem(IconData icon, String label, int index) {
    final isSelected = _currentIndex == index;
    final color = isSelected ? Theme.of(context).primaryColor : Colors.grey;
    return IconButton(
      icon: Icon(icon, color: color),
      onPressed: () => _onTabTapped(index),
      tooltip: label,
    );
  }
}
// lib/presentation/screens/party_details_screen.dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart'
    as intl
    hide TextDirection; // <-- ØªØ¬Ù†Ù‘Ø¨ ØªØ¶Ø§Ø±Ø¨ TextDirection
import 'package:youssef_fabric_ledger/data/local/database_helper.dart';
import 'package:youssef_fabric_ledger/data/models/debt_entry.dart';
import 'package:youssef_fabric_ledger/data/models/party.dart';
import '../widgets/debt_action_bar.dart';
import '../widgets/debt_transaction_modal.dart';

class PartyDetailsScreen extends StatefulWidget {
  final Party party;
  final double initialBalance;

  const PartyDetailsScreen({
    required this.party,
    required this.initialBalance,
    super.key,
  });

  @override
  State<PartyDetailsScreen> createState() => _PartyDetailsScreenState();
}

class _PartyDetailsScreenState extends State<PartyDetailsScreen> {
  Future<List<DebtEntry>>? _entriesFuture;
  
  @override
  void initState() {
    super.initState();
    _reload();
  }
  
  /// Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  void _reload() {
    setState(() {
      _entriesFuture = DatabaseHelper.instance.getDebtEntriesForParty(widget.party.id!);
    });
  }
  
  /// Ø­Ø³Ø§Ø¨ Ø§Ù„Ø±ØµÙŠØ¯ Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª
  double _computeBalance(List<DebtEntry> entries, Party party) {
    double balance = 0.0;
    final bool isVendor = party.type == 'vendor';
    
    for (final entry in entries) {
      if (isVendor) {
        // Ù„Ù„Ù…ÙˆØ±Ø¯ÙŠÙ†: Ø§Ù„Ø´Ø±Ø§Ø¡ ÙˆØ§Ù„Ø¥Ù‚Ø±Ø§Ø¶ ÙŠØ²ÙŠØ¯ Ù…Ø§ Ø£Ø¯ÙŠÙ† Ø¨Ù‡ (Ù…ÙˆØ¬Ø¨)
        // Ø§Ù„ØªØ³Ø¯ÙŠØ¯ ÙˆØ§Ù„Ø§Ø³ØªÙ„Ø§Ù… ÙŠÙ†Ù‚Øµ (Ø³Ø§Ù„Ø¨)
        if (entry.kind == 'purchase_credit' || entry.kind == 'loan_out') {
          balance += entry.amount;
        } else if (entry.kind == 'payment' || entry.kind == 'settlement') {
          balance -= entry.amount;
        }
      } else {
        // Ù„Ù„Ø£Ø´Ø®Ø§Øµ: Ø§Ù„Ø¥Ù‚Ø±Ø§Ø¶ ÙˆØ§Ù„Ø´Ø±Ø§Ø¡ ÙŠØ²ÙŠØ¯ Ù…Ø§ ÙŠØ¯ÙŠÙ†ÙˆÙ† Ù„ÙŠ (Ù…ÙˆØ¬Ø¨)
        // Ø§Ù„ØªØ³Ø¯ÙŠØ¯ ÙˆØ§Ù„Ø§Ø³ØªÙ„Ø§Ù… ÙŠÙ†Ù‚Øµ (Ø³Ø§Ù„Ø¨)
        if (entry.kind == 'loan_out' || entry.kind == 'purchase_credit') {
          balance += entry.amount;
        } else if (entry.kind == 'payment' || entry.kind == 'settlement') {
          balance -= entry.amount;
        }
      }
    }
    
    return balance;
  }

  @override
  Widget build(BuildContext context) {
    final currencyFormat = intl.NumberFormat.currency(
      locale: 'en',
      symbol: 'Ø¯.Ø¬',
    );
    final bool isVendor = widget.party.type == 'vendor';

    return Directionality(
      textDirection: TextDirection.rtl,
      child: Scaffold(
        appBar: AppBar(
          title: Text(widget.party.name),
        ),
        body: Column(
          children: [
            // Ø§Ø³ØªØ®Ø¯Ø§Ù… FutureBuilder ÙˆØ§Ø­Ø¯ Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ§Ù„Ø±ØµÙŠØ¯
            Expanded(
              child: FutureBuilder<List<DebtEntry>>(
                future: _entriesFuture,
                builder: (context, snapshot) {
                  if (snapshot.connectionState == ConnectionState.waiting) {
                    return const Center(child: CircularProgressIndicator());
                  }
                  
                  final entries = snapshot.data ?? [];
                  final currentBalance = _computeBalance(entries, widget.party);
                  
                  return Column(
                    children: [
                      // Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ø±ØµÙŠØ¯
                      _buildBalanceCard(context, currencyFormat, isVendor, currentBalance),
                      // Ù‚Ø³Ù… Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª
                      if (entries.isEmpty)
                        Expanded(child: _buildEmptyState())
                      else ...[
                        // Ø¹Ù†ÙˆØ§Ù† Ù‚Ø³Ù… Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª
                        Container(
                          width: double.infinity,
                          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                          child: Text(
                            'Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª (${entries.length})',
                            textAlign: TextAlign.right,
                            style: TextStyle(
                              color: Theme.of(context).primaryColor,
                              fontSize: 16,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                        ),
                        // Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª
                        Expanded(
                          child: ListView.builder(
                            padding: const EdgeInsets.symmetric(horizontal: 16),
                            itemCount: entries.length,
                            itemBuilder: (context, index) {
                              final entry = entries[index];
                              return _buildTransactionCard(entry, currencyFormat);
                            },
                          ),
                        ),
                      ],
                    ],
                  );
                },
              ),
            ),
          ],
        ),
        bottomNavigationBar: DebtActionBar(
          onFirstActionPressed: () => _handleFirstAction(context, isVendor),
          onSecondActionPressed: () => _handleSecondAction(context, isVendor),
          isVendor: isVendor,
        ),
      ),
    );
  }

  /// Ø¨Ø·Ø§Ù‚Ø© Ø¹Ø±Ø¶ Ø§Ù„Ø±ØµÙŠØ¯
  Widget _buildBalanceCard(BuildContext context, intl.NumberFormat currencyFormat, bool isVendor, double currentBalance) {
    // ØªØ­Ø¯ÙŠØ¯ Ù„ÙˆÙ† Ø§Ù„Ù…Ø¨Ù„Øº ÙˆØ§Ù„Ù†Øµ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯
    Color amountColor;
    String helperText;
    IconData? circularIcon;
    
    if (currentBalance == 0) {
      amountColor = Colors.grey.shade700;
      helperText = 'Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø±ØµÙŠØ¯';
      circularIcon = null;
    } else if (isVendor) {
      if (currentBalance > 0) {
        // Ù…ÙˆØ±Ø¯ + Ø±ØµÙŠØ¯ Ù…ÙˆØ¬Ø¨ = Ø£Ù†Øª Ù…Ø¯ÙŠÙ† Ù„Ù‡ (Ø£Ø­Ù…Ø±)
        amountColor = Colors.red.shade700;
        helperText = 'Ù…Ø³ØªØ­Ù‚ Ù„Ù‡';
        circularIcon = Icons.keyboard_arrow_up;
      } else {
        // Ù…ÙˆØ±Ø¯ + Ø±ØµÙŠØ¯ Ø³Ø§Ù„Ø¨ = Ù…Ø³ØªØ­Ù‚ Ù„Ùƒ Ù…Ù†Ù‡ (Ø£Ø®Ø¶Ø±)
        amountColor = Colors.green.shade700;
        helperText = 'Ù…Ø³ØªØ­Ù‚ Ù…Ù†Ù‡';
        circularIcon = Icons.keyboard_arrow_down;
      }
    } else {
      if (currentBalance > 0) {
        // Ø´Ø®Øµ + Ø±ØµÙŠØ¯ Ù…ÙˆØ¬Ø¨ = Ù…Ø³ØªØ­Ù‚ Ù„Ùƒ Ù…Ù†Ù‡ (Ø£Ø®Ø¶Ø±)
        amountColor = Colors.green.shade700;
        helperText = 'Ù…Ø³ØªØ­Ù‚ Ù…Ù†Ù‡';
        circularIcon = Icons.keyboard_arrow_down;
      } else {
        // Ø´Ø®Øµ + Ø±ØµÙŠØ¯ Ø³Ø§Ù„Ø¨ = Ø£Ù†Øª Ù…Ø¯ÙŠÙ† Ù„Ù‡ (Ø£Ø­Ù…Ø±)
        amountColor = Colors.red.shade700;
        helperText = 'Ù…Ø³ØªØ­Ù‚ Ù„Ù‡';
        circularIcon = Icons.keyboard_arrow_up;
      }
    }

    return Container(
      margin: const EdgeInsets.fromLTRB(16, 12, 16, 12),
      padding: const EdgeInsets.all(18),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(18),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.08),
            blurRadius: 12,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Row(
        children: [
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // ØªØ³Ù…ÙŠØ© Ø§Ù„Ø±ØµÙŠØ¯
                Text(
                  'Ø§Ù„Ø±ØµÙŠØ¯',
                  style: TextStyle(
                    color: Theme.of(context).primaryColor,
                    fontSize: 13,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                const SizedBox(height: 4),
                // Ø§Ù„Ù…Ø¨Ù„Øº
                Text(
                  currencyFormat.format(currentBalance.abs()),
                  style: TextStyle(
                    color: amountColor,
                    fontSize: 28,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 2),
                // Ø§Ù„Ù†Øµ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯
                Text(
                  helperText,
                  style: TextStyle(
                    color: Colors.grey.shade600,
                    fontSize: 12,
                  ),
                ),
              ],
            ),
          ),
          // Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø© Ø§Ù„Ø¯Ø§Ø¦Ø±ÙŠØ©
          if (circularIcon != null)
            Container(
              width: 40,
              height: 40,
              decoration: BoxDecoration(
                color: amountColor.withOpacity(0.1),
                shape: BoxShape.circle,
              ),
              child: Icon(
                circularIcon,
                color: amountColor,
                size: 24,
              ),
            ),
        ],
      ),
    );
  }

  /// ÙˆÙŠØ¯Ø¬Øª Ù„Ø¹Ø±Ø¶ Ø­Ø§Ù„Ø© ÙØ§Ø±ØºØ© Ø¹Ù†Ø¯ Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ Ù…Ø¹Ø§Ù…Ù„Ø§Øª
  Widget _buildEmptyState() {
    return Padding(
      padding: const EdgeInsets.only(bottom: 80), // Ù…Ø³Ø§Ø­Ø© Ù„Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø³ÙÙ„ÙŠØ©
      child: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              widget.party.type == 'vendor' ? Icons.store_outlined : Icons.person_outline,
              size: 64,
              color: Colors.grey,
            ),
            const SizedBox(height: 16),
            Text(
              'Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ù…Ø¹ ${widget.party.name}',
              style: const TextStyle(
                fontSize: 18,
                color: Colors.grey,
                fontWeight: FontWeight.w500,
              ),
            ),
            const SizedBox(height: 8),
            const Text(
              'Ø³ØªØ¸Ù‡Ø± Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ù‡Ù†Ø§ Ø¹Ù†Ø¯ Ø¥Ø¶Ø§ÙØªÙ‡Ø§',
              style: TextStyle(
                fontSize: 14,
                color: Colors.grey,
              ),
            ),
          ],
        ),
      ),
    );
  }



  /// Ø¨Ø·Ø§Ù‚Ø© Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø© Ø§Ù„ÙˆØ§Ø­Ø¯Ø©
  Widget _buildTransactionCard(
    DebtEntry entry,
    intl.NumberFormat currencyFormat,
  ) {
    // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø©ØŒ Ø§Ù„Ù„ÙˆÙ†ØŒ ÙˆØ§Ù„Ù†Øµ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†ÙˆØ¹ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©
    IconData icon;
    Color color;
    String title;
    String relationText;

    final bool isDebtIncrease =
        entry.kind == 'purchase_credit' || entry.kind == 'loan_out';

    if (isDebtIncrease) {
      color = Colors.red;
      if (widget.party.type == 'vendor') {
        title = 'Ø´Ø±Ø§Ø¡ Ø¨Ø§Ù„Ø¯ÙŠÙ†';
        relationText = 'Ù…Ø³ØªØ­Ù‚ Ù„Ù€ ${widget.party.name}';
      } else {
        title = 'Ø¥Ù‚Ø±Ø§Ø¶ Ù…Ø¨Ù„Øº';
        relationText = 'Ù…Ø³ØªØ­Ù‚ Ù…Ù† ${widget.party.name}';
      }
      icon = Icons.arrow_upward;
    } else {
      color = Colors.green;
      if (widget.party.type == 'vendor') {
        title = 'ØªØ³Ø¯ÙŠØ¯ Ø¯ÙØ¹Ø©';
        relationText = 'Ø¯ÙØ¹ Ù„Ù€ ${widget.party.name}';
      } else {
        title = 'Ø§Ø³ØªÙ„Ø§Ù… Ø¯ÙØ¹Ø©';
        relationText = 'Ø§Ø³ØªÙ„Ø§Ù… Ù…Ù† ${widget.party.name}';
      }
      icon = Icons.arrow_downward;
    }

    // ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØªØ§Ø±ÙŠØ® Ø¨Ø´ÙƒÙ„ Ø·Ø¨ÙŠØ¹ÙŠ Ù…Ø¹ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ù„Ø§ØªÙŠÙ†ÙŠØ©
    final dateFormat = intl.DateFormat('dd/MM/yyyy', 'en');
    final formattedDate = dateFormat.format(entry.date);

    return Container(
      margin: const EdgeInsets.symmetric(vertical: 8),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.08),
            blurRadius: 12,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Column(
        children: [
          // Ø§Ù„ØµÙ Ø§Ù„Ø¹Ù„ÙˆÙŠ: Ø§Ù„Ø¹Ù†ÙˆØ§Ù† ÙˆØ§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø©
          Row(
            children: [
              Expanded(
                child: Text(
                  title,
                  style: const TextStyle(
                    fontWeight: FontWeight.bold,
                    fontSize: 16,
                  ),
                ),
              ),
              Container(
                width: 32,
                height: 32,
                decoration: BoxDecoration(
                  color: color.withOpacity(0.1),
                  shape: BoxShape.circle,
                ),
                child: Icon(
                  icon,
                  color: color,
                  size: 18,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          // Ø§Ù„Ù…Ø¨Ù„Øº
          Row(
            children: [
              Expanded(
                child: Text(
                  currencyFormat.format(entry.amount),
                  style: TextStyle(
                    color: color,
                    fontWeight: FontWeight.bold,
                    fontSize: 18,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          // Ø§Ù„ØµÙ Ø§Ù„Ø³ÙÙ„ÙŠ: Ø§Ù„ØªØ§Ø±ÙŠØ® ÙˆØ§Ù„Ø±ØµÙŠØ¯
          Row(
            children: [
              Expanded(
                child: Text(
                  formattedDate,
                  style: TextStyle(
                    color: Colors.grey.shade600,
                    fontSize: 12,
                  ),
                ),
              ),
              Text(
                relationText,
                style: TextStyle(
                  color: Colors.grey.shade600,
                  fontSize: 12,
                ),
              ),
            ],
          ),
          // Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù…ÙˆØ¬ÙˆØ¯Ø©
          if (entry.note != null && entry.note!.isNotEmpty) ...[
            const SizedBox(height: 8),
            Container(
              width: double.infinity,
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
              decoration: BoxDecoration(
                color: Colors.grey.shade100,
                borderRadius: BorderRadius.circular(8),
              ),
              child: Row(
                children: [
                  Icon(
                    Icons.note_alt_outlined,
                    size: 14,
                    color: Colors.grey.shade600,
                  ),
                  const SizedBox(width: 6),
                  Expanded(
                    child: Text(
                      entry.note!,
                      style: TextStyle(
                        color: Colors.grey.shade700,
                        fontSize: 12,
                        fontStyle: FontStyle.italic,
                      ),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ],
      ),
    );
  }



  /// Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø²Ø± Ø§Ù„Ø£ÙˆÙ„ (Ø´Ø±Ø§Ø¡ Ù„Ù„Ù…ÙˆØ±Ø¯ÙŠÙ† Ø£Ùˆ Ø¥Ù‚Ø±Ø§Ø¶ Ù„Ù„Ø£Ø´Ø®Ø§Øµ)
  void _handleFirstAction(BuildContext context, bool isVendor) async {
    final transactionKind = isVendor ? 'purchase_credit' : 'loan_out';
    final result = await showDebtTransactionModal(
      context: context,
      party: widget.party,
      transactionKind: transactionKind,
    );
    
    if (result == true && mounted) {
      _reload();
    }
  }

  /// Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø²Ø± Ø§Ù„Ø«Ø§Ù†ÙŠ (ØªØ³Ø¯ÙŠØ¯ Ù„Ù„Ù…ÙˆØ±Ø¯ÙŠÙ† Ø£Ùˆ Ø§Ø³ØªÙ„Ø§Ù… Ù„Ù„Ø£Ø´Ø®Ø§Øµ)
  void _handleSecondAction(BuildContext context, bool isVendor) async {
    final transactionKind = isVendor ? 'payment' : 'settlement';
    final result = await showDebtTransactionModal(
      context: context,
      party: widget.party,
      transactionKind: transactionKind,
    );
    
    if (result == true && mounted) {
      _reload();
    }
  }
}
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'dart:ui' as ui;
import 'package:provider/provider.dart';
import 'package:youssef_fabric_ledger/logic/providers/date_provider.dart';
import 'package:youssef_fabric_ledger/logic/providers/finance_provider.dart';
import 'package:youssef_fabric_ledger/presentation/screens/settings_screen.dart';

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  @override
  void initState() {
    super.initState();
    // Data is now fetched automatically by the provider when the date changes.
    // We can trigger an initial fetch here if needed, but it's handled by the provider's constructor.
    WidgetsBinding.instance.addPostFrameCallback((_) {
      context.read<FinanceProvider>().fetchFinancialDataForSelectedDate();
    });
  }

  @override
  Widget build(BuildContext context) {
    final currencyFormat = NumberFormat.currency(
      locale: 'ar',
      symbol: 'Ø¯.Ø¬ ',
      decimalDigits: 2,
    );
    final dateProvider = context.watch<DateProvider>();

    return Scaffold(
      backgroundColor: Colors.transparent,
      body: Consumer<FinanceProvider>(
        builder: (context, financeProvider, child) {
          return CustomScrollView(
            slivers: [
              SliverAppBar(
                title: const Text('Ø¯ÙØªØ± Ø£Ù‚Ù…Ø´Ø© ÙŠÙˆØ³Ù'),
                pinned: true,
                floating: true,
                actions: [
                  IconButton(
                    icon: const Icon(Icons.settings_outlined),
                    onPressed: () {
                      Navigator.of(context).push(
                        MaterialPageRoute(
                          builder: (context) => const SettingsScreen(),
                        ),
                      );
                    },
                    tooltip: 'Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª',
                  ),
                ],
                bottom: PreferredSize(
                  preferredSize: const Size.fromHeight(60.0),
                  child: Padding(
                    padding: const EdgeInsets.all(8.0),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        IconButton(
                          icon: const Icon(
                            Icons.chevron_left,
                            color: Colors.white,
                          ),
                          onPressed: () => dateProvider.previousDay(),
                        ),
                        Text(
                          DateFormat.yMMMMEEEEd(
                            'ar',
                          ).format(dateProvider.selectedDate),
                          style: const TextStyle(
                            color: Colors.white,
                            fontSize: 16,
                          ),
                        ),
                        IconButton(
                          icon: const Icon(
                            Icons.chevron_right,
                            color: Colors.white,
                          ),
                          onPressed: () => dateProvider.nextDay(),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
              SliverPadding(
                padding: const EdgeInsets.all(16.0),
                sliver: SliverList(
                  delegate: SliverChildListDelegate([
                    // Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù†Ù‚Ø¯ÙŠ
                    _buildEditableBalanceCard(
                      context,
                      'Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù†Ù‚Ø¯ÙŠ',
                      currencyFormat.format(financeProvider.totalCashBalance),
                      Icons.account_balance,
                      Colors.purple,
                    ),

                    // ØµÙ 1: Ù…ØµØ±ÙˆÙØ§Øª Ø§Ù„ÙŠÙˆÙ… + Ø¯Ø®Ù„ Ø§Ù„ÙŠÙˆÙ…
                    Row(
                      children: [
                        Expanded(
                          child: _buildSmallSummaryCard(
                            'Ù…ØµØ±ÙˆÙØ§Øª Ø§Ù„ÙŠÙˆÙ…',
                            currencyFormat.format(
                              financeProvider.totalExpenses,
                            ),
                            Colors.orange,
                          ),
                        ),
                        const SizedBox(width: 16),
                        Expanded(
                          child: _buildSmallSummaryCard(
                            'Ø¯Ø®Ù„ Ø§Ù„ÙŠÙˆÙ…',
                            currencyFormat.format(financeProvider.totalIncome),
                            Colors.teal,
                          ),
                        ),
                      ],
                    ),

                    // ØµÙ 2: Ø±Ø¨Ø­ Ø§Ù„ÙŠÙˆÙ… (20%)
                    Row(
                      children: [
                        Expanded(
                          child: _buildSmallSummaryCard(
                            'Ø±Ø¨Ø­ Ø§Ù„ÙŠÙˆÙ… (20%)',
                            currencyFormat.format(financeProvider.dailyProfit),
                            Colors.green,
                          ),
                        ),
                      ],
                    ),

                    // Ø¨Ø·Ø§Ù‚Ø©: ØµØ§ÙÙŠ Ø±Ø¨Ø­ Ø§Ù„ÙŠÙˆÙ… = Ø±Ø¨Ø­ Ø§Ù„ÙŠÙˆÙ… - Ù…ØµØ±ÙˆÙØ§Øª Ø§Ù„ÙŠÙˆÙ…
                    _buildSummaryCard(
                      'ØµØ§ÙÙŠ Ø±Ø¨Ø­ Ø§Ù„ÙŠÙˆÙ…',
                      currencyFormat.format(financeProvider.netProfit),
                      Icons.account_balance_wallet,
                      Colors.blue,
                    ),

                    // Ø­Ø§Ù„Ø© Ø§Ù„Ø¯Ø±Ø¬
                    _buildDrawerStatusCard(),
                  ]),
                ),
              ),
            ],
          );
        },
      ),
    );
  }

  Widget _buildEditableBalanceCard(
    BuildContext context,
    String title,
    String value,
    IconData icon,
    Color color,
  ) {
    return Card(
      elevation: 4.0,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Row(
              children: [
                Icon(icon, size: 40, color: color),
                const SizedBox(width: 16),
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(title, style: Theme.of(context).textTheme.titleLarge),
                    Directionality(
                      textDirection: ui.TextDirection.rtl,
                      child: Text(
                        value,
                        style: const TextStyle(
                          fontSize: 20,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ],
                ),
              ],
            ),
            IconButton(
              icon: const Icon(Icons.edit, color: Colors.grey),
              onPressed: () => _showEditBalanceDialog(context),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSummaryCard(
    String title,
    String value,
    IconData icon,
    Color color,
  ) {
    return Card(
      elevation: 4.0,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
      margin: const EdgeInsets.symmetric(vertical: 8.0),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Row(
          children: [
            Icon(icon, size: 40, color: color),
            const SizedBox(width: 16),
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(title, style: Theme.of(context).textTheme.titleLarge),
                Directionality(
                  textDirection: ui.TextDirection.rtl,
                  child: Text(
                    value,
                    style: const TextStyle(
                      fontSize: 20,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSmallSummaryCard(String title, String value, Color color) {
    return Card(
      elevation: 2.0,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
      margin: const EdgeInsets.symmetric(vertical: 8.0),
      child: Padding(
        padding: const EdgeInsets.all(12.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(title, style: Theme.of(context).textTheme.titleMedium),
            const SizedBox(height: 8),
            Directionality(
              textDirection: ui.TextDirection.rtl,
              child: Text(
                value,
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                  color: color,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildDrawerStatusCard() {
    return Consumer<FinanceProvider>(
      builder: (context, financeProvider, child) {
        final status = financeProvider.drawerFinalState;
        final currencyFormat = NumberFormat.currency(
          locale: 'ar',
          symbol: 'Ø¯.Ø¬ ',
          decimalDigits: 2,
        );

        return Card(
          elevation: 4.0,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(10),
          ),
          margin: const EdgeInsets.symmetric(vertical: 8.0),
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Ø­Ø§Ù„Ø© Ø§Ù„Ø¯Ø±Ø¬ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©',
                  style: Theme.of(context).textTheme.titleLarge,
                ),
                const SizedBox(height: 16),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceAround,
                  children: [
                    _buildStatusColumn(
                      'Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø§ÙØªØªØ§Ø­ÙŠ',
                      currencyFormat.format(status['openingBalance'] ?? 0.0),
                      Icons.login,
                      Colors.blueGrey,
                    ),
                    _buildStatusColumn(
                      'Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø®ØªØ§Ù…ÙŠ',
                      currencyFormat.format(status['closingBalance'] ?? 0.0),
                      Icons.logout,
                      Colors.blueGrey,
                    ),
                    _buildStatusColumn(
                      'Ø§Ù„ÙØ±Ù‚',
                      currencyFormat.format(status['difference'] ?? 0.0),
                      (status['difference'] ?? 0.0) >= 0
                          ? Icons.arrow_upward
                          : Icons.arrow_downward,
                      (status['difference'] ?? 0.0) >= 0
                          ? Colors.green
                          : Colors.red,
                    ),
                  ],
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildStatusColumn(
    String title,
    String value,
    IconData icon,
    Color color,
  ) {
    return Column(
      children: [
        Icon(icon, color: color, size: 30),
        const SizedBox(height: 8),
        Text(
          title,
          style: const TextStyle(fontSize: 14, fontWeight: FontWeight.w500),
        ),
        const SizedBox(height: 4),
        Directionality(
          textDirection: ui.TextDirection.rtl,
          child: Text(
            value,
            style: TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.bold,
              color: color,
            ),
          ),
        ),
      ],
    );
  }

  void _showEditBalanceDialog(BuildContext context) {
    final financeProvider = Provider.of<FinanceProvider>(
      context,
      listen: false,
    );
    final TextEditingController controller = TextEditingController(
      text: financeProvider.totalCashBalance.toStringAsFixed(2),
    );

    showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: const Text('ØªØ¹Ø¯ÙŠÙ„ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù†Ù‚Ø¯ÙŠ'),
          content: TextField(
            controller: controller,
            keyboardType: const TextInputType.numberWithOptions(decimal: true),
            decoration: const InputDecoration(
              labelText: 'Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯',
              prefixText: 'Ø¯.Ø¬ ',
            ),
            textDirection: ui.TextDirection.rtl,
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('Ø¥Ù„ØºØ§Ø¡'),
            ),
            TextButton(
              onPressed: () {
                final double? newBalance = double.tryParse(controller.text);
                if (newBalance != null) {
                  financeProvider.updateTotalCashBalance(newBalance);
                  Navigator.of(context).pop();
                }
              },
              child: const Text('Ø­ÙØ¸'),
            ),
          ],
        );
      },
    );
  }
}
import 'package:flutter/material.dart';

/// Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù…Ø´ØªØ±ÙƒØ© Ù„Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª ÙÙŠ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚
class ActionButtonStyles {
  // Ø§Ù„Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
  static const Color redColor = Color(0xFFE53E3E);
  static const Color greenColor = Color(0xFF38A169);
  
  /// Ù†Ù…Ø· Ø§Ù„Ø²Ø± Ø§Ù„Ø£Ø­Ù…Ø± Ù„Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ù…Ø«Ù„ Ø§Ù„Ø¥Ù‚Ø±Ø§Ø¶ ÙˆØ§Ù„Ø´Ø±Ø§Ø¡
  static ButtonStyle get redActionStyle {
    return FilledButton.styleFrom(
      backgroundColor: redColor,
      foregroundColor: Colors.white,
      minimumSize: const Size(double.infinity, 52),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      elevation: 0,
      shadowColor: Colors.transparent,
      textStyle: const TextStyle(
        fontSize: 16,
        fontWeight: FontWeight.w700,
      ),
      padding: const EdgeInsets.symmetric(horizontal: 16),
    ).copyWith(
      overlayColor: WidgetStateProperty.resolveWith<Color?>(
        (Set<WidgetState> states) {
          if (states.contains(WidgetState.pressed)) {
            return Colors.black.withOpacity(0.1);
          }
          return null;
        },
      ),
    );
  }
  
  /// Ù†Ù…Ø· Ø§Ù„Ø²Ø± Ø§Ù„Ø£Ø®Ø¶Ø± Ù„Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ù…Ø«Ù„ Ø§Ù„Ø§Ø³ØªÙ„Ø§Ù… ÙˆØ§Ù„ØªØ³Ø¯ÙŠØ¯
  static ButtonStyle get greenActionStyle {
    return FilledButton.styleFrom(
      backgroundColor: greenColor,
      foregroundColor: Colors.white,
      minimumSize: const Size(double.infinity, 52),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      elevation: 0,
      shadowColor: Colors.transparent,
      textStyle: const TextStyle(
        fontSize: 16,
        fontWeight: FontWeight.w700,
      ),
      padding: const EdgeInsets.symmetric(horizontal: 16),
    ).copyWith(
      overlayColor: WidgetStateProperty.resolveWith<Color?>(
        (Set<WidgetState> states) {
          if (states.contains(WidgetState.pressed)) {
            return Colors.black.withOpacity(0.1);
          }
          return null;
        },
      ),
    );
  }
}// lib/presentation/widgets/parties_list_view.dart
import 'package:flutter/material.dart';
import 'package:youssef_fabric_ledger/data/local/database_helper.dart';
import 'package:youssef_fabric_ledger/data/models/party.dart';

class PartiesListView extends StatefulWidget {
  final String partyType;
  const PartiesListView({required this.partyType, super.key});

  @override
  _PartiesListViewState createState() => _PartiesListViewState();
}

class _PartiesListViewState extends State<PartiesListView> {
  late Future<List<Party>> _partiesFuture;

  @override
  void initState() {
    super.initState();
    _partiesFuture = DatabaseHelper.instance.getParties(widget.partyType);
  }

  // --- âœ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ù‡Ù… Ù‡Ù†Ø§ ---
  // Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø³Ø­Ø±ÙŠØ© ØªÙØ³ØªØ¯Ø¹Ù‰ ÙƒÙ„Ù…Ø§ ØªØºÙŠØ± Ø§Ù„ÙˆÙŠØ¯Ø¬Øª Ø§Ù„Ø£Ø¨
  // Ø³Ù†Ø³ØªØ®Ø¯Ù…Ù‡Ø§ Ù„Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ù†Ø¯ ØªØºÙŠÙŠØ± partyType
  @override
  void didUpdateWidget(PartiesListView oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.partyType != widget.partyType) {
      // Ø¥Ø°Ø§ ØªØºÙŠØ± Ù†ÙˆØ¹ Ø§Ù„Ø·Ø±Ù (Ù…Ù† vendor Ø¥Ù„Ù‰ person Ø£Ùˆ Ø§Ù„Ø¹ÙƒØ³)ØŒ Ù‚Ù… Ø¨Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      refreshData();
    }
  }

  // --- Ù†Ù‡Ø§ÙŠØ© Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ ---
  // --- âœ… Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ù…Ù† Ø§Ù„Ø®Ø§Ø±Ø¬ ---
  void refreshData() {
    setState(() {
      _partiesFuture = DatabaseHelper.instance.getParties(widget.partyType);
    });
  }

  @override
  Widget build(BuildContext context) {
    return FutureBuilder<List<Party>>(
      future: _partiesFuture,
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        }
        if (!snapshot.hasData || snapshot.data!.isEmpty) {
          // --- ØªØ¹Ø¯ÙŠÙ„ Ø¨Ø³ÙŠØ· Ù‡Ù†Ø§ Ù„ØªØ­Ø³ÙŠÙ† Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„ÙØ§Ø±ØºØ© ---
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  widget.partyType == 'vendor'
                      ? Icons.store_outlined
                      : Icons.person_outline,
                  size: 64,
                  color: Colors.grey.shade400,
                ),
                const SizedBox(height: 16),
                Text(
                  'Ù„Ø§ ÙŠÙˆØ¬Ø¯ ${widget.partyType == 'vendor' ? 'Ù…ÙˆØ±Ø¯ÙŠÙ†' : 'Ø£Ø´Ø®Ø§Øµ'} Ø­Ø§Ù„ÙŠØ§Ù‹',
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(
                    color: Colors.grey.shade600,
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  'Ø§Ø³ØªØ®Ø¯Ù… Ø²Ø± "+" ÙÙŠ Ø§Ù„Ø£Ø³ÙÙ„ Ù„Ø¥Ø¶Ø§ÙØ© Ø£ÙˆÙ„ ${widget.partyType == 'vendor' ? 'Ù…ÙˆØ±Ø¯' : 'Ø´Ø®Øµ'}.',
                  style: Theme.of(
                    context,
                  ).textTheme.bodyMedium?.copyWith(color: Colors.grey.shade600),
                  textAlign: TextAlign.center,
                ),
              ],
            ),
          );
        }

        final parties = snapshot.data!;
        return ListView.builder(
          // Ø¥Ø¶Ø§ÙØ© padding Ù„ØªØ¬Ù†Ø¨ ØªØºØ·ÙŠØ© Ø§Ù„Ø²Ø± Ø§Ù„Ø³ÙÙ„ÙŠ
          padding: const EdgeInsets.only(bottom: 90.0),
          itemCount: parties.length,
          itemBuilder: (context, index) {
            final party = parties[index];
            return PartyBalanceCard(party: party);
          },
        );
      },
    );
  }
}

/// ÙˆÙŠØ¯Ø¬Øª Ù„Ø¹Ø±Ø¶ Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ø·Ø±Ù Ù…Ø¹ Ø±ØµÙŠØ¯Ù‡
class PartyBalanceCard extends StatefulWidget {
  final Party party;

  const PartyBalanceCard({super.key, required this.party});

  @override
  State<PartyBalanceCard> createState() => _PartyBalanceCardState();
}

class _PartyBalanceCardState extends State<PartyBalanceCard> {
  double balance = 0.0;
  bool isLoading = true;

  @override
  void initState() {
    super.initState();
    _loadBalance();
  }

  /// ØªØ­Ù…ÙŠÙ„ Ø±ØµÙŠØ¯ Ø§Ù„Ø·Ø±Ù
  Future<void> _loadBalance() async {
    try {
      final partyBalance = await DatabaseHelper.instance.getPartyBalance(
        widget.party.id!,
      );
      setState(() {
        balance = partyBalance;
        isLoading = false;
      });
    } catch (e) {
      setState(() {
        isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final isPositive = balance > 0;
    final isZero = balance == 0;

    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
      child: ListTile(
        leading: CircleAvatar(
          backgroundColor: isZero
              ? Colors.grey
              : isPositive
              ? Colors.red.shade100
              : Colors.green.shade100,
          child: Icon(
            widget.party.type == 'vendor' ? Icons.store : Icons.person,
            color: isZero
                ? Colors.grey.shade600
                : isPositive
                ? Colors.red.shade700
                : Colors.green.shade700,
          ),
        ),
        title: Text(
          widget.party.name,
          style: const TextStyle(fontWeight: FontWeight.bold),
        ),
        subtitle: widget.party.phone != null && widget.party.phone!.isNotEmpty
            ? Text(widget.party.phone!)
            : null,
        trailing: isLoading
            ? const SizedBox(
                width: 20,
                height: 20,
                child: CircularProgressIndicator(strokeWidth: 2),
              )
            : Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.end,
                children: [
                  Text(
                    '${balance.abs().toStringAsFixed(2)} Ø¬.Ù…',
                    style: TextStyle(
                      fontWeight: FontWeight.bold,
                      fontSize: 16,
                      color: isZero
                          ? Colors.grey
                          : isPositive
                          ? Colors.red
                          : Colors.green,
                    ),
                  ),
                  Text(
                    isZero
                        ? 'Ù…ØªÙˆØ§Ø²Ù†'
                        : isPositive
                        ? (widget.party.type == 'vendor'
                              ? 'Ù…Ø³ØªØ­Ù‚ Ù„Ù‡'
                              : 'Ù…Ø³ØªØ­Ù‚ Ù…Ù†Ù‡')
                        : (widget.party.type == 'vendor'
                              ? 'Ù…Ø³ØªØ­Ù‚ Ù…Ù†Ù‡'
                              : 'Ù…Ø³ØªØ­Ù‚ Ù„Ù‡'),
                    style: TextStyle(fontSize: 12, color: Colors.grey.shade600),
                  ),
                ],
              ),
        onTap: () {
          // ÙŠÙ…ÙƒÙ† Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØªÙ†Ù‚Ù„ Ø¥Ù„Ù‰ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø·Ø±Ù Ù‡Ù†Ø§
        },
      ),
    );
  }
}
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../core/enums.dart';
import '../../data/models/expense.dart';
import '../../data/models/income.dart';
import '../../data/models/drawer_snapshot.dart';
import '../../data/local/database_helper.dart';
import '../../logic/providers/finance_provider.dart';
import '../../data/models/category.dart';
import 'package:intl/intl.dart' hide TextDirection;

class AddTransactionModal extends StatefulWidget {
  // --- âœ… Ø§Ù„Ø¥Ø¶Ø§ÙØ© Ù‡Ù†Ø§ ---
  final Expense? expenseToEdit; // Ù…ØµØ±ÙˆÙ Ø§Ø®ØªÙŠØ§Ø±ÙŠ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„

  const AddTransactionModal({this.expenseToEdit, super.key});
  // --- Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ø¥Ø¶Ø§ÙØ© ---

  @override
  AddTransactionModalState createState() => AddTransactionModalState();
}

class AddTransactionModalState extends State<AddTransactionModal>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;

  @override
  void initState() {
    super.initState();
    // --- âœ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‡Ù†Ø§: ØªÙ‚Ù„ÙŠÙ„ Ø¹Ø¯Ø¯ Ø§Ù„ØªØ¨ÙˆÙŠØ¨Ø§Øª Ø¥Ù„Ù‰ 3 ---
    _tabController = TabController(length: 3, vsync: this);
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Directionality(
      textDirection: TextDirection.rtl,
      child: SizedBox(
        height: MediaQuery.of(context).size.height * 0.75,
        child: Column(
          children: [
            const SizedBox(height: 12),
            Container(
              width: 40,
              height: 5,
              decoration: BoxDecoration(
                color: Colors.grey[300],
                borderRadius: BorderRadius.circular(10),
              ),
            ),
            const SizedBox(height: 16),
            // Ø´Ø±ÙŠØ· Ø§Ù„ØªØ¨ÙˆÙŠØ¨Ø§Øª
            TabBar(
              controller: _tabController,
              isScrollable: true,
              tabs: const [
                // --- âœ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‡Ù†Ø§: Ø¥Ø²Ø§Ù„Ø© ØªØ¨ÙˆÙŠØ¨ "Ø¯ÙŠÙˆÙ†" ---
                Tab(text: "Ù…ØµØ±ÙˆÙ", icon: Icon(Icons.payment)),
                Tab(text: "Ø¯Ø®Ù„", icon: Icon(Icons.attach_money)),
                Tab(text: "Ø¯Ø±Ø¬", icon: Icon(Icons.inbox_outlined)),
              ],
            ),
            // Ù…Ø­ØªÙˆÙ‰ Ø§Ù„ØªØ¨ÙˆÙŠØ¨Ø§Øª
            Expanded(
              child: TabBarView(
                controller: _tabController,
                children: [
                  // --- âœ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‡Ù†Ø§: Ø¥Ø²Ø§Ù„Ø© ÙˆØ§Ø¬Ù‡Ø© "Ø¯ÙŠÙˆÙ†" ---
                  ExpenseForm(expenseToEdit: widget.expenseToEdit),
                  const IncomeForm(),
                  const DrawerForm(),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

// Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ù…ØµØ±ÙˆÙØ§Øª

class ExpenseForm extends StatefulWidget {
  // --- âœ… Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø§Ù„Ù…ØµØ±ÙˆÙ Ù‡Ù†Ø§ ---
  final Expense? expenseToEdit;
  const ExpenseForm({this.expenseToEdit, super.key});

  @override
  ExpenseFormState createState() => ExpenseFormState();
}

class ExpenseFormState extends State<ExpenseForm> {
  final _formKey = GlobalKey<FormState>();
  final _amountController = TextEditingController();
  final _noteController = TextEditingController();

  // --- âœ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª ---
  late DateTime _selectedDate;
  late TransactionSource _selectedSource;
  int? _selectedCategoryId;
  List<Category> _categories = [];
  bool _isLoading = false;
  late bool _isEditing; // Ù…ØªØºÙŠØ± Ù„ØªØ­Ø¯ÙŠØ¯ ÙˆØ¶Ø¹ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„

  @override
  void initState() {
    super.initState();
    _isEditing = widget.expenseToEdit != null;
    _initializeFields();
    _loadCategories();
  }

  // --- âœ… Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø­Ù‚ÙˆÙ„ ---
  void _initializeFields() {
    if (_isEditing) {
      final expense = widget.expenseToEdit!;
      _amountController.text = expense.amount.toString();
      _noteController.text = expense.note ?? '';
      _selectedDate = expense.date;
      _selectedSource = expense.source;
      _selectedCategoryId = expense.categoryId;
    } else {
      _selectedDate = DateTime.now();
      _selectedSource = TransactionSource.cash;
    }
  }

  /// ØªØ­Ù…ÙŠÙ„ ÙØ¦Ø§Øª Ø§Ù„Ù…ØµØ±ÙˆÙØ§Øª
  Future<void> _loadCategories() async {
    try {
      final categories = await DatabaseHelper.instance.getCategories('expense');
      setState(() {
        _categories = categories;
        if (_categories.isNotEmpty) {
          _selectedCategoryId = _categories.first.id;
        }
      });
    } catch (e) {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(SnackBar(content: Text('Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙØ¦Ø§Øª: $e')));
    }
  }

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      padding: EdgeInsets.all(16),
      child: Form(
        key: _formKey,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            // Ø­Ù‚Ù„ Ø§Ù„Ù…Ø¨Ù„Øº
            TextFormField(
              controller: _amountController,
              keyboardType: TextInputType.numberWithOptions(decimal: true),
              decoration: InputDecoration(
                labelText: 'Ø§Ù„Ù…Ø¨Ù„Øº',
                prefixIcon: Icon(Icons.attach_money),
                border: OutlineInputBorder(),
              ),
              validator: (value) {
                if (value == null || value.isEmpty) {
                  return 'ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù…Ø¨Ù„Øº';
                }
                if (double.tryParse(value) == null) {
                  return 'ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­';
                }
                return null;
              },
            ),
            SizedBox(height: 16),

            // Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ¦Ø©
            DropdownButtonFormField<int>(
              value: _selectedCategoryId,
              decoration: InputDecoration(
                labelText: 'Ø§Ù„ÙØ¦Ø©',
                prefixIcon: Icon(Icons.category),
                border: OutlineInputBorder(),
              ),
              items: _categories.map((category) {
                return DropdownMenuItem<int>(
                  value: category.id,
                  child: Row(
                    children: [
                      Icon(
                        IconData(
                          category.iconCodePoint,
                          fontFamily: 'MaterialIcons',
                        ),
                      ),
                      SizedBox(width: 8),
                      Text(category.name),
                    ],
                  ),
                );
              }).toList(),
              onChanged: (value) {
                setState(() {
                  _selectedCategoryId = value;
                });
              },
              validator: (value) {
                if (value == null) {
                  return 'ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± ÙØ¦Ø©';
                }
                return null;
              },
            ),
            SizedBox(height: 16),

            // Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…ØµØ¯Ø±
            DropdownButtonFormField<TransactionSource>(
              value: _selectedSource,
              decoration: const InputDecoration(
                labelText: 'Ø§Ù„Ù…ØµØ¯Ø±',
                prefixIcon: Icon(Icons.account_balance_wallet),
                border: OutlineInputBorder(),
              ),
              items: const [
                DropdownMenuItem(
                  value: TransactionSource.cash,
                  child: Text('Ù†Ù‚Ø¯ÙŠ'),
                ),
                DropdownMenuItem(
                  value: TransactionSource.drawer,
                  child: Text('Ø¯Ø±Ø¬'),
                ),
                DropdownMenuItem(
                  value: TransactionSource.bank,
                  child: Text('Ø¨Ù†Ùƒ'),
                ),
              ],
              onChanged: (value) {
                setState(() {
                  _selectedSource = value!;
                });
              },
            ),
            SizedBox(height: 16),

            // Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ØªØ§Ø±ÙŠØ®
            ListTile(
              leading: Icon(Icons.calendar_today),
              title: Text('Ø§Ù„ØªØ§Ø±ÙŠØ®'),
              subtitle: Text(
                '${_selectedDate.day}/${_selectedDate.month}/${_selectedDate.year}',
              ),
              onTap: () => _selectDate(context),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8),
                side: BorderSide(color: Colors.grey),
              ),
            ),
            SizedBox(height: 16),

            // Ø­Ù‚Ù„ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø©
            TextFormField(
              controller: _noteController,
              maxLines: 3,
              decoration: InputDecoration(
                labelText: 'Ù…Ù„Ø§Ø­Ø¸Ø© (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)',
                prefixIcon: Icon(Icons.note),
                border: OutlineInputBorder(),
              ),
            ),
            SizedBox(height: 24),

            // Ø²Ø± Ø§Ù„Ø­ÙØ¸
            ElevatedButton(
              onPressed: _isLoading ? null : _saveExpense,
              child: _isLoading
                  ? CircularProgressIndicator(color: Colors.white)
                  : Text('Ø­ÙØ¸ Ø§Ù„Ù…ØµØ±ÙˆÙ'),
              style: ElevatedButton.styleFrom(
                padding: EdgeInsets.symmetric(vertical: 16),
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ØªØ§Ø±ÙŠØ®
  Future<void> _selectDate(BuildContext context) async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate,
      firstDate: DateTime(2020),
      lastDate: DateTime.now(),
    );
    if (picked != null && picked != _selectedDate) {
      setState(() {
        _selectedDate = picked;
      });
    }
  }

  // --- âœ… ØªØ¹Ø¯ÙŠÙ„ Ø¯Ø§Ù„Ø© Ø§Ù„Ø­ÙØ¸ ---
  Future<void> _saveExpense() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() {
      _isLoading = true;
    });

    try {
      // Ø¥Ù†Ø´Ø§Ø¡ ÙƒØ§Ø¦Ù† Expense Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø¥Ø¶Ø§ÙØ© Ø£Ùˆ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„
      final expense = Expense(
        id: _isEditing
            ? widget.expenseToEdit!.id
            : null, // Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù€ ID Ø§Ù„Ù‚Ø¯ÙŠÙ… Ø¹Ù†Ø¯ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„
        date: _selectedDate,
        amount: double.parse(_amountController.text),
        categoryId: _selectedCategoryId!,
        source: _selectedSource,
        note: _noteController.text.isNotEmpty ? _noteController.text : null,
        createdAt: _isEditing
            ? widget.expenseToEdit!.createdAt
            : DateTime.now(), // Ø§Ø­ØªÙØ¸ Ø¨ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£ØµÙ„ÙŠ
      );

      // Use the provider to save the expense
      await Provider.of<FinanceProvider>(
        context,
        listen: false,
      ).addOrUpdateExpense(expense);

      if (mounted) {
        Navigator.pop(context, true);
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(const SnackBar(content: Text('ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù…ØµØ±ÙˆÙ Ø¨Ù†Ø¬Ø§Ø­')));
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text('Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ø§Ù„Ù…ØµØ±ÙˆÙ: $e')));
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  void dispose() {
    _amountController.dispose();
    _noteController.dispose();
    super.dispose();
  }
}

// Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ø¯Ø®Ù„
class IncomeForm extends StatefulWidget {
  const IncomeForm({super.key});

  @override
  IncomeFormState createState() => IncomeFormState();
}

class IncomeFormState extends State<IncomeForm> {
  final _formKey = GlobalKey<FormState>();
  final _amountController = TextEditingController();
  final _noteController = TextEditingController();
  DateTime _selectedDate = DateTime.now();
  TransactionSource _selectedSource = TransactionSource.drawer;
  bool _isLoading = false;

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      padding: EdgeInsets.all(16),
      child: Form(
        key: _formKey,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            // Ø­Ù‚Ù„ Ø§Ù„Ù…Ø¨Ù„Øº
            TextFormField(
              controller: _amountController,
              keyboardType: TextInputType.numberWithOptions(decimal: true),
              decoration: InputDecoration(
                labelText: 'Ø§Ù„Ù…Ø¨Ù„Øº',
                prefixIcon: Icon(Icons.attach_money),
                border: OutlineInputBorder(),
              ),
              validator: (value) {
                if (value == null || value.isEmpty) {
                  return 'ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù…Ø¨Ù„Øº';
                }
                if (double.tryParse(value) == null) {
                  return 'ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… ØµØ­ÙŠØ­';
                }
                return null;
              },
            ),
            SizedBox(height: 16),

            // Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…ØµØ¯Ø±
            DropdownButtonFormField<TransactionSource>(
              value: _selectedSource,
              decoration: const InputDecoration(
                labelText: 'Ø§Ù„Ù…ØµØ¯Ø±',
                prefixIcon: Icon(Icons.account_balance_wallet),
                border: OutlineInputBorder(),
              ),
              items: const [
                DropdownMenuItem(
                  value: TransactionSource.drawer,
                  child: Text('Ø¯Ø±Ø¬'),
                ),
                DropdownMenuItem(
                  value: TransactionSource.bank,
                  child: Text('Ø¨Ù†Ùƒ'),
                ),
              ],
              onChanged: (value) {
                setState(() {
                  _selectedSource = value!;
                });
              },
            ),
            SizedBox(height: 16),

            // Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ØªØ§Ø±ÙŠØ®
            ListTile(
              leading: Icon(Icons.calendar_today),
              title: Text('Ø§Ù„ØªØ§Ø±ÙŠØ®'),
              subtitle: Text(
                '${_selectedDate.day}/${_selectedDate.month}/${_selectedDate.year}',
              ),
              onTap: () => _selectDate(context),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8),
                side: BorderSide(color: Colors.grey),
              ),
            ),
            SizedBox(height: 16),

            // Ø­Ù‚Ù„ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø©
            TextFormField(
              controller: _noteController,
              maxLines: 3,
              decoration: InputDecoration(
                labelText: 'Ù…Ù„Ø§Ø­Ø¸Ø© (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)',
                prefixIcon: Icon(Icons.note),
                border: OutlineInputBorder(),
              ),
            ),
            SizedBox(height: 24),

            // Ø²Ø± Ø§Ù„Ø­ÙØ¸
            ElevatedButton(
              onPressed: _isLoading ? null : _saveIncome,
              child: _isLoading
                  ? CircularProgressIndicator(color: Colors.white)
                  : Text('Ø­ÙØ¸ Ø§Ù„Ø¯Ø®Ù„'),
              style: ElevatedButton.styleFrom(
                padding: EdgeInsets.symmetric(vertical: 16),
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ØªØ§Ø±ÙŠØ®
  Future<void> _selectDate(BuildContext context) async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate,
      firstDate: DateTime(2020),
      lastDate: DateTime.now(),
    );
    if (picked != null && picked != _selectedDate) {
      setState(() {
        _selectedDate = picked;
      });
    }
  }

  /// Ø­ÙØ¸ Ø§Ù„Ø¯Ø®Ù„
  Future<void> _saveIncome() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() {
      _isLoading = true;
    });

    try {
      final income = Income(
        date: _selectedDate,
        amount: double.parse(_amountController.text),
        source: _selectedSource,
        note: _noteController.text.isEmpty ? null : _noteController.text,
        createdAt: DateTime.now(),
      );

      await DatabaseHelper.instance.createIncome(income);

      // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ Ø§Ù„Ù…Ø²ÙˆØ¯
      if (mounted) {
        Provider.of<FinanceProvider>(context, listen: false).refreshTodayData();
        Navigator.pop(context);
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text('ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø¯Ø®Ù„ Ø¨Ù†Ø¬Ø§Ø­')));
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text('Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ø§Ù„Ø¯Ø®Ù„: $e')));
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  void dispose() {
    _amountController.dispose();
    _noteController.dispose();
    super.dispose();
  }
}

// Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ø¯ÙŠÙˆÙ†

// Ø¯Ø§Ø®Ù„ Ù…Ù„Ù add_transaction_modal.dartØŒ Ø§Ø³ØªØ¨Ø¯Ù„ Ø§Ù„ÙƒÙ„Ø§Ø³Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ø¨Ù‡Ø°Ø§
class DrawerForm extends StatefulWidget {
  const DrawerForm({super.key});

  @override
  DrawerFormState createState() => DrawerFormState();
}

class DrawerFormState extends State<DrawerForm> {
  final _formKey = GlobalKey<FormState>();
  final _amountController = TextEditingController();
  final _noteController = TextEditingController();

  DateTime _selectedDate = DateTime.now();
  // Ù…ØªØºÙŠØ± Ù„ØªØ®Ø²ÙŠÙ† Ù†ÙˆØ¹ Ø§Ù„Ù„Ù‚Ø·Ø© Ø§Ù„Ù…Ø®ØªØ§Ø±Ø© ('start' or 'end')
  SnapshotType _selectedType = SnapshotType.start;

  @override
  void dispose() {
    _amountController.dispose();
    _noteController.dispose();
    super.dispose();
  }

  // Ø­ÙØ¸ Ù„Ù‚Ø·Ø© Ø§Ù„Ø¯Ø±Ø¬
  Future<void> _saveSnapshot() async {
    if (!(_formKey.currentState?.validate() ?? false)) {
      return;
    }

    final amount = double.parse(_amountController.text);
    final note = _noteController.text;

    final snapshot = DrawerSnapshot(
      date: _selectedDate,
      type: _selectedType,
      cashAmount: amount,
      note: note.isNotEmpty ? note : null,
      createdAt: DateTime.now(),
    );

    await DatabaseHelper.instance.saveDrawerSnapshot(snapshot);

    if (mounted) {
      // Ù„Ø§ ØªØ­ØªØ§Ø¬ Ù„Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„Ù€ Provider Ù‡Ù†Ø§ Ù„Ø£Ù†Ù†Ø§ Ø³Ù†Ù‚ÙˆÙ… Ø¨Ø°Ù„Ùƒ ÙÙŠ main_layout

      // --- Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‡Ù†Ø§ ---
      Navigator.of(context).pop(true); // Ø£Ø±Ø¬Ø¹ 'true' Ù„Ù„Ø¥Ø´Ø§Ø±Ø© Ø¥Ù„Ù‰ Ø§Ù„Ù†Ø¬Ø§Ø­
      // --- Ù†Ù‡Ø§ÙŠØ© Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ ---

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            'ØªÙ… Ø­ÙØ¸ Ø±ØµÙŠØ¯ ${_selectedType == SnapshotType.start ? 'Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©' : 'Ø§Ù„Ù†Ù‡Ø§ÙŠØ©'} Ø¨Ù†Ø¬Ø§Ø­',
          ),
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Form(
      key: _formKey,
      child: ListView(
        padding: const EdgeInsets.all(16.0),
        children: [
          const Text(
            "ØªØ³Ø¬ÙŠÙ„ Ø±ØµÙŠØ¯ Ø§Ù„Ø¯Ø±Ø¬",
            style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 24),

          // 1. Ù…Ø­Ø¯Ø¯ Ø§Ù„ØªØ§Ø±ÙŠØ®
          ListTile(
            contentPadding: EdgeInsets.zero,
            title: const Text(
              'Ø§Ù„ØªØ§Ø±ÙŠØ®',
              style: TextStyle(fontWeight: FontWeight.w500),
            ),
            subtitle: Text(DateFormat.yMMMMEEEEd('ar').format(_selectedDate)),
            trailing: const Icon(Icons.calendar_today_outlined),
            onTap: () async {
              final pickedDate = await showDatePicker(
                context: context,
                initialDate: _selectedDate,
                firstDate: DateTime(2020),
                lastDate: DateTime.now().add(const Duration(days: 1)),
              );
              if (pickedDate != null) {
                setState(() {
                  _selectedDate = pickedDate;
                });
              }
            },
          ),
          const SizedBox(height: 16),

          // 2. Ø­Ù‚Ù„ Ø§Ù„Ù…Ø¨Ù„Øº
          TextFormField(
            controller: _amountController,
            keyboardType: const TextInputType.numberWithOptions(decimal: true),
            decoration: const InputDecoration(
              labelText: 'Ø§Ù„Ù…Ø¨Ù„Øº',
              border: OutlineInputBorder(
                borderRadius: BorderRadius.all(Radius.circular(12)),
              ),
              suffixText: 'Ø¯.Ø¬',
              prefixIcon: Icon(Icons.money),
            ),
            validator: (value) {
              if (value == null ||
                  value.isEmpty ||
                  double.tryParse(value) == null) {
                return 'Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ù…Ø¨Ù„Øº ØµØ­ÙŠØ­';
              }
              return null;
            },
          ),
          const SizedBox(height: 16),

          // 3. Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ù†Ø³Ø¯Ù„Ø© (Ø¨Ø¯Ø§ÙŠØ© / Ù†Ù‡Ø§ÙŠØ©)
          DropdownButtonFormField<SnapshotType>(
            value: _selectedType,
            decoration: const InputDecoration(
              labelText: 'Ù†ÙˆØ¹ Ø§Ù„Ø±ØµÙŠØ¯',
              border: OutlineInputBorder(
                borderRadius: BorderRadius.all(Radius.circular(12)),
              ),
              prefixIcon: Icon(Icons.sync_alt),
            ),
            items: const [
              DropdownMenuItem(
                value: SnapshotType.start,
                child: Text('Ø±ØµÙŠØ¯ Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„ÙŠÙˆÙ…'),
              ),
              DropdownMenuItem(
                value: SnapshotType.end,
                child: Text('Ø±ØµÙŠØ¯ Ù†Ù‡Ø§ÙŠØ© Ø§Ù„ÙŠÙˆÙ…'),
              ),
            ],
            onChanged: (value) {
              if (value != null) {
                setState(() {
                  _selectedType = value;
                });
              }
            },
          ),
          const SizedBox(height: 16),

          // 4. Ø­Ù‚Ù„ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª
          TextFormField(
            controller: _noteController,
            decoration: const InputDecoration(
              labelText: 'Ù…Ù„Ø§Ø­Ø¸Ø© (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)',
              border: OutlineInputBorder(
                borderRadius: BorderRadius.all(Radius.circular(12)),
              ),
              prefixIcon: Icon(Icons.note_alt_outlined),
            ),
          ),
          const SizedBox(height: 32),

          // 5. Ø²Ø± Ø§Ù„Ø­ÙØ¸
          FilledButton.icon(
            icon: const Icon(Icons.save),
            label: const Text('Ø­ÙØ¸', style: TextStyle(fontSize: 16)),
            onPressed: _saveSnapshot,
            style: FilledButton.styleFrom(
              padding: const EdgeInsets.symmetric(vertical: 16),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(12),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
import 'package:flutter/material.dart';
import '../../data/local/database_helper.dart';
import '../../data/models/debt_entry.dart';
import '../../data/models/party.dart';
import 'package:provider/provider.dart';
import '../../logic/providers/finance_provider.dart';

/// Ù†Ù…ÙˆØ°Ø¬ Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ø§Ù…Ù„Ø© Ø¯ÙŠÙ† Ù…Ø®ØµØµ Ù„Ø·Ø±Ù Ù…Ø¹ÙŠÙ†
class DebtTransactionModal extends StatefulWidget {
  final Party party;
  final String transactionKind; // 'purchase_credit', 'payment', 'loan_out', 'settlement'
  final VoidCallback? onTransactionSaved;
  
  const DebtTransactionModal({
    super.key,
    required this.party,
    required this.transactionKind,
    this.onTransactionSaved,
  });

  @override
  State<DebtTransactionModal> createState() => _DebtTransactionModalState();
}

class _DebtTransactionModalState extends State<DebtTransactionModal> {
  final _formKey = GlobalKey<FormState>();
  final _amountController = TextEditingController();
  final _noteController = TextEditingController();
  bool _isLoading = false;

  @override
  void dispose() {
    _amountController.dispose();
    _noteController.dispose();
    super.dispose();
  }

  /// Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†ÙˆØ¹ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©
  String get _getTitle {
    switch (widget.transactionKind) {
      case 'purchase_credit':
        return 'Ø´Ø±Ø§Ø¡ Ø¨Ø§Ù„Ø¯ÙŠÙ† Ù…Ù† ${widget.party.name}';
      case 'payment':
        return 'ØªØ³Ø¯ÙŠØ¯ Ø¯ÙØ¹Ø© Ù„Ù€ ${widget.party.name}';
      case 'loan_out':
        return 'Ø¥Ù‚Ø±Ø§Ø¶ Ù…Ø¨Ù„Øº Ù„Ù€ ${widget.party.name}';
      case 'settlement':
        return 'Ø§Ø³ØªÙ„Ø§Ù… Ø¯ÙØ¹Ø© Ù…Ù† ${widget.party.name}';
      default:
        return 'Ù…Ø¹Ø§Ù…Ù„Ø© Ù…Ø¹ ${widget.party.name}';
    }
  }

  /// Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø£ÙŠÙ‚ÙˆÙ†Ø© Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†ÙˆØ¹ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©
  IconData get _getIcon {
    switch (widget.transactionKind) {
      case 'purchase_credit':
        return Icons.shopping_cart;
      case 'payment':
        return Icons.payment;
      case 'loan_out':
        return Icons.arrow_upward;
      case 'settlement':
        return Icons.arrow_downward;
      default:
        return Icons.account_balance_wallet;
    }
  }

  /// Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù„ÙˆÙ† Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†ÙˆØ¹ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©
  Color get _getColor {
    switch (widget.transactionKind) {
      case 'purchase_credit':
      case 'loan_out':
        return Colors.red.shade600; // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø¯ÙŠÙ†
      case 'payment':
      case 'settlement':
        return Colors.green.shade600; // ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø¯ÙŠÙ†
      default:
        return Colors.blue.shade600;
    }
  }

  /// Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù†Øµ Ø§Ù„Ø²Ø± Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†ÙˆØ¹ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©
  String get _getButtonText {
    switch (widget.transactionKind) {
      case 'purchase_credit':
        return 'ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø´Ø±Ø§Ø¡';
      case 'payment':
        return 'ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØªØ³Ø¯ÙŠØ¯';
      case 'loan_out':
        return 'ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¥Ù‚Ø±Ø§Ø¶';
      case 'settlement':
        return 'ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø§Ø³ØªÙ„Ø§Ù…';
      default:
        return 'Ø­ÙØ¸ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©';
    }
  }

  @override
  Widget build(BuildContext context) {
    return Directionality(
      textDirection: TextDirection.rtl,
      child: Container(
        height: MediaQuery.of(context).size.height * 0.6,
        padding: const EdgeInsets.all(20),
        decoration: const BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
        ),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // Ù…Ù‚Ø¨Ø¶ Ø§Ù„Ø³Ø­Ø¨
              Center(
                child: Container(
                  width: 40,
                  height: 5,
                  decoration: BoxDecoration(
                    color: Colors.grey[300],
                    borderRadius: BorderRadius.circular(10),
                  ),
                ),
              ),
              const SizedBox(height: 20),
              
              // Ø§Ù„Ø¹Ù†ÙˆØ§Ù† Ù…Ø¹ Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø©
              Row(
                children: [
                  Icon(_getIcon, color: _getColor, size: 28),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Text(
                      _getTitle,
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                        color: _getColor,
                      ),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 24),
              
              // Ø­Ù‚Ù„ Ø§Ù„Ù…Ø¨Ù„Øº
              TextFormField(
                controller: _amountController,
                keyboardType: const TextInputType.numberWithOptions(decimal: true),
                decoration: InputDecoration(
                  labelText: 'Ø§Ù„Ù…Ø¨Ù„Øº',
                  border: const OutlineInputBorder(
                    borderRadius: BorderRadius.all(Radius.circular(12)),
                  ),
                  suffixText: 'Ø¯.Ø¬',
                  prefixIcon: Icon(Icons.money, color: _getColor),
                ),
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù…Ø¨Ù„Øº';
                  }
                  if (double.tryParse(value) == null || double.parse(value) <= 0) {
                    return 'Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ù…Ø¨Ù„Øº ØµØ­ÙŠØ­';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              
              // Ø­Ù‚Ù„ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª
              TextFormField(
                controller: _noteController,
                decoration: const InputDecoration(
                  labelText: 'Ù…Ù„Ø§Ø­Ø¸Ø§Øª (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)',
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.all(Radius.circular(12)),
                  ),
                  prefixIcon: Icon(Icons.note_alt_outlined),
                ),
                maxLines: 3,
              ),
              const Spacer(),
              
              // Ø²Ø± Ø§Ù„Ø­ÙØ¸
              FilledButton.icon(
                icon: _isLoading 
                    ? const SizedBox(
                        width: 20,
                        height: 20,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          color: Colors.white,
                        ),
                      )
                    : Icon(_getIcon),
                label: Text(
                  _isLoading ? 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸...' : _getButtonText,
                  style: const TextStyle(fontSize: 16),
                ),
                onPressed: _isLoading ? null : _saveTransaction,
                style: FilledButton.styleFrom(
                  backgroundColor: _getColor,
                  padding: const EdgeInsets.symmetric(vertical: 16),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  /// Ø­ÙØ¸ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  void _saveTransaction() async {
    if (!(_formKey.currentState?.validate() ?? false)) return;
    
    setState(() {
      _isLoading = true;
    });

    try {
      final debtEntry = DebtEntry(
        date: DateTime.now(),
        partyId: widget.party.id!,
        kind: widget.transactionKind,
        amount: double.parse(_amountController.text),
        note: _noteController.text.isNotEmpty ? _noteController.text : null,
        createdAt: DateTime.now(),
      );
      
      await DatabaseHelper.instance.createDebtEntry(debtEntry);

      if (mounted) {
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ Ø§Ù„Ù…Ø²ÙˆØ¯
        context.read<FinanceProvider>().fetchFinancialDataForSelectedDate();
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ Ø§Ù„Ø´Ø§Ø´Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
        widget.onTransactionSaved?.call();
        
        Navigator.of(context).pop(true);
        
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('ØªÙ… Ø­ÙØ¸ ${_getSuccessMessage()} Ø¨Ù†Ø¬Ø§Ø­'),
            backgroundColor: Colors.green,
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø­ÙØ¸: $e'),
            backgroundColor: Colors.red,
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  /// Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù†Ø¬Ø§Ø­ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†ÙˆØ¹ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©
  String _getSuccessMessage() {
    switch (widget.transactionKind) {
      case 'purchase_credit':
        return 'Ù…Ø¹Ø§Ù…Ù„Ø© Ø§Ù„Ø´Ø±Ø§Ø¡';
      case 'payment':
        return 'Ù…Ø¹Ø§Ù…Ù„Ø© Ø§Ù„ØªØ³Ø¯ÙŠØ¯';
      case 'loan_out':
        return 'Ù…Ø¹Ø§Ù…Ù„Ø© Ø§Ù„Ø¥Ù‚Ø±Ø§Ø¶';
      case 'settlement':
        return 'Ù…Ø¹Ø§Ù…Ù„Ø© Ø§Ù„Ø§Ø³ØªÙ„Ø§Ù…';
      default:
        return 'Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø©';
    }
  }
}

/// Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ÙØªØ­ Ù†Ù…ÙˆØ°Ø¬ Ù…Ø¹Ø§Ù…Ù„Ø© Ø§Ù„Ø¯ÙŠÙ†
Future<bool?> showDebtTransactionModal({
  required BuildContext context,
  required Party party,
  required String transactionKind,
  VoidCallback? onTransactionSaved,
}) {
  return showModalBottomSheet<bool>(
    context: context,
    isScrollControlled: true,
    backgroundColor: Colors.transparent,
    builder: (context) => DebtTransactionModal(
      party: party,
      transactionKind: transactionKind,
      onTransactionSaved: onTransactionSaved,
    ),
  );
}import 'package:flutter/material.dart';
import '../theme/action_button_styles.dart';

/// Ø´Ø±ÙŠØ· Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø§Ù„Ø³ÙÙ„ÙŠ Ù„Ù„Ø¯ÙŠÙˆÙ† - Ù‚Ø§Ø¨Ù„ Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
class DebtActionBar extends StatelessWidget {
  /// Ø¯Ø§Ù„Ø© Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø§Ù„Ø£ÙˆÙ„ (Ø¥Ù‚Ø±Ø§Ø¶ Ù„Ù„Ø£Ø´Ø®Ø§Øµ Ø£Ùˆ Ø´Ø±Ø§Ø¡ Ù„Ù„Ù…ÙˆØ±Ø¯ÙŠÙ†)
  final VoidCallback onFirstActionPressed;
  
  /// Ø¯Ø§Ù„Ø© Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø§Ù„Ø«Ø§Ù†ÙŠ (Ø§Ø³ØªÙ„Ø§Ù… Ù„Ù„Ø£Ø´Ø®Ø§Øµ Ø£Ùˆ ØªØ³Ø¯ÙŠØ¯ Ù„Ù„Ù…ÙˆØ±Ø¯ÙŠÙ†)
  final VoidCallback onSecondActionPressed;
  
  /// Ù‡Ù„ Ø§Ù„Ø·Ø±Ù Ù…ÙˆØ±Ø¯ØŸ (Ù„ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ø£Ø²Ø±Ø§Ø±)
  final bool isVendor;
  
  const DebtActionBar({
    super.key,
    required this.onFirstActionPressed,
    required this.onSecondActionPressed,
    required this.isVendor,
  });
  
  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
        decoration: BoxDecoration(
          color: Theme.of(context).scaffoldBackgroundColor,
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.05),
              blurRadius: 8,
              offset: const Offset(0, -2),
            ),
          ],
        ),
        child: Row(
          children: [
            // Ø§Ù„Ø²Ø± Ø§Ù„Ø£ÙˆÙ„ (Ø£Ø­Ù…Ø±)
            Expanded(
              child: FilledButton.icon(
                onPressed: onFirstActionPressed,
                style: ActionButtonStyles.redActionStyle,
                icon: Icon(
                  isVendor ? Icons.shopping_cart : Icons.arrow_upward,
                  size: 20,
                ),
                label: Text(isVendor ? 'Ø´Ø±Ø§Ø¡' : 'Ø¥Ù‚Ø±Ø§Ø¶'),
              ),
            ),
            
            // Ù…Ø³Ø§ÙØ© Ø¨ÙŠÙ† Ø§Ù„Ø£Ø²Ø±Ø§Ø±
            const SizedBox(width: 12),
            
            // Ø§Ù„Ø²Ø± Ø§Ù„Ø«Ø§Ù†ÙŠ (Ø£Ø®Ø¶Ø±)
            Expanded(
              child: FilledButton.icon(
                onPressed: onSecondActionPressed,
                style: ActionButtonStyles.greenActionStyle,
                icon: Icon(
                  isVendor ? Icons.payment : Icons.arrow_downward,
                  size: 20,
                ),
                label: Text(isVendor ? 'ØªØ³Ø¯ÙŠØ¯' : 'Ø§Ø³ØªÙ„Ø§Ù…'),
              ),
            ),
          ],
        ),
      ),
    );
  }
}// lib/presentation/widgets/party_balance_card.dart

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:youssef_fabric_ledger/data/local/database_helper.dart';
import 'package:youssef_fabric_ledger/data/models/party.dart';
// ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ù‡Ø°Ø§ Ø§Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯ ØµØ­ÙŠØ­ ÙˆÙŠØ´ÙŠØ± Ø¥Ù„Ù‰ Ù…ÙƒØ§Ù† Ù…Ù„Ù Ø´Ø§Ø´Ø© Ø§Ù„ØªÙØ§ØµÙŠÙ„
import 'package:youssef_fabric_ledger/presentation/screens/party_details_screen.dart';

class PartyBalanceCard extends StatelessWidget {
  final Party party;
  const PartyBalanceCard({required this.party, super.key});

  @override
  Widget build(BuildContext context) {
    // ØªÙ‡ÙŠØ¦Ø© ØµÙŠØºØ© Ø§Ù„Ø¹Ù…Ù„Ø© Ù…Ø¹ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ù„Ø§ØªÙŠÙ†ÙŠØ©
    final currencyFormat = NumberFormat.currency(locale: 'en', symbol: 'Ø¯.Ø¬');

    // Ù†Ø³ØªØ®Ø¯Ù… FutureBuilder Ù„Ø¬Ù„Ø¨ Ø§Ù„Ø±ØµÙŠØ¯ Ø¨Ø´ÙƒÙ„ ØºÙŠØ± Ù…ØªØ²Ø§Ù…Ù† Ù„ÙƒÙ„ Ø¨Ø·Ø§Ù‚Ø© Ø¹Ù„Ù‰ Ø­Ø¯Ø©
    return FutureBuilder<double>(
      future: DatabaseHelper.instance.getPartyBalance(party.id!),
      builder: (context, snapshot) {
        // Ø£Ø«Ù†Ø§Ø¡ Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŒ ÙŠÙ…ÙƒÙ† Ø¹Ø±Ø¶ Ø¹Ù†ØµØ± Ù†Ø§Ø¦Ø¨ Ø¨Ø³ÙŠØ·
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const ListTile(
            title: Text("... Ø¬Ø§Ø±ÙŠ Ø­Ø³Ø§Ø¨ Ø§Ù„Ø±ØµÙŠØ¯"),
            subtitle: LinearProgressIndicator(),
          );
        }

        // ÙÙŠ Ø­Ø§Ù„ Ø­Ø¯ÙˆØ« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        if (snapshot.hasError) {
          return ListTile(
            title: Text(party.name),
            subtitle: const Text(
              "Ø®Ø·Ø£ ÙÙŠ Ø­Ø³Ø§Ø¨ Ø§Ù„Ø±ØµÙŠØ¯",
              style: TextStyle(color: Colors.red),
            ),
          );
        }

        // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ Ø¨ÙŠØ§Ù†Ø§Øª (ÙˆÙ‡Ùˆ Ø£Ù…Ø± ØºÙŠØ± Ù…Ø±Ø¬Ø­ Ø¥Ù„Ø§ ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ø®Ø·Ø£)
        if (!snapshot.hasData) {
          return const SizedBox.shrink();
        }

        final balance = snapshot.data!;
        // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø±ØµÙŠØ¯ ØµÙØ±Ø§Ù‹ØŒ Ù„Ø§ Ù†Ø¹Ø±Ø¶ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© Ù„ØªÙ†Ø¸ÙŠÙ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©
        if (balance == 0) {
          return const SizedBox.shrink();
        }

        // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù†ØµÙˆØµ ÙˆØ§Ù„Ø£Ù„ÙˆØ§Ù† Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†ÙˆØ¹ Ø§Ù„Ø·Ø±Ù (Ù…ÙˆØ±Ø¯ Ø£Ù… Ø´Ø®Øµ)
        final bool isVendor = party.type == 'vendor';
        final String label = isVendor ? "Ù…Ø³ØªØ­Ù‚ Ù„Ù‡:" : "Ù…Ø³ØªØ­Ù‚ Ù…Ù†Ù‡:";
        final Color balanceColor = isVendor
            ? Colors.red.shade700
            : Colors.green.shade700;

        return Card(
          margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          elevation: 1,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
          child: ListTile(
            leading: CircleAvatar(
              backgroundColor: Theme.of(context).primaryColor.withOpacity(0.1),
              foregroundColor: Theme.of(context).primaryColor,
              child: Text(party.name.substring(0, 1)),
            ),
            title: Text(
              party.name,
              style: const TextStyle(fontWeight: FontWeight.bold),
            ),
            subtitle: Text(label),
            trailing: Text(
              currencyFormat.format(
                balance.abs(),
              ), // .abs() Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ø·Ù„Ù‚Ø© Ø¯Ø§Ø¦Ù…Ø§Ù‹
              style: TextStyle(
                color: balanceColor,
                fontWeight: FontWeight.bold,
                fontSize: 16,
              ),
            ),
            // Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ø£Ù‡Ù…: Ø¹Ù†Ø¯ Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©
            onTap: () {
              // ØªÙ†ÙÙŠØ° Ø£Ù…Ø± Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„Ù‰ Ø´Ø§Ø´Ø© Ø§Ù„ØªÙØ§ØµÙŠÙ„
              Navigator.of(context).push(
                MaterialPageRoute(
                  builder: (context) => PartyDetailsScreen(
                    party: party, // Ù†Ù…Ø±Ø± Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ø±Ù
                    initialBalance: balance, // Ù†Ù…Ø±Ø± Ø§Ù„Ø±ØµÙŠØ¯ Ø§Ù„Ù…Ø­Ø³ÙˆØ¨
                  ),
                ),
              );
            },
          ),
        );
      },
    );
  }
}
// lib/presentation/widgets/drawer_history_log.dart

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:collection/collection.dart';
import 'package:provider/provider.dart';
import 'package:youssef_fabric_ledger/core/enums.dart';
import 'package:youssef_fabric_ledger/data/local/database_helper.dart';
import 'package:youssef_fabric_ledger/data/models/drawer_snapshot.dart';
import 'package:youssef_fabric_ledger/logic/providers/finance_provider.dart';

class DrawerHistoryLog extends StatefulWidget {
  const DrawerHistoryLog({super.key});

  @override
  DrawerHistoryLogState createState() => DrawerHistoryLogState();
}

class DrawerHistoryLogState extends State<DrawerHistoryLog> {
  List<DrawerSnapshot> _snapshots = [];
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _loadSnapshots();
  }

  Future<void> _loadSnapshots() async {
    setState(() {
      _isLoading = true;
    });
    final snapshots = await DatabaseHelper.instance.getAllDrawerSnapshots();
    setState(() {
      _snapshots = snapshots;
      _isLoading = false;
    });
  }

  // --- âœ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‡Ù†Ø§: Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø¢Ù† ØªØ³ØªÙ‚Ø¨Ù„ ID ---
  Future<void> _deleteSnapshot(int id, SnapshotType type) async {
    final confirm = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø°Ù'),
        content: Text(
          'Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ø±ØµÙŠØ¯ ${type == SnapshotType.start ? 'Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©' : 'Ø§Ù„Ù†Ù‡Ø§ÙŠØ©'} Ù„Ù‡Ø°Ø§ Ø§Ù„ÙŠÙˆÙ…ØŸ',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('Ø¥Ù„ØºØ§Ø¡'),
          ),
          FilledButton(
            onPressed: () => Navigator.of(context).pop(true),
            child: const Text('Ø­Ø°Ù'),
          ),
        ],
      ),
    );

    if (confirm == true && mounted) {
      // --- âœ… ÙˆÙ‡Ù†Ø§: Ù†Ø³ØªØ¯Ø¹ÙŠ Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„ØµØ­ÙŠØ­Ø© ---
      await DatabaseHelper.instance.deleteDrawerSnapshot(id);
      Provider.of<FinanceProvider>(context, listen: false).refreshTodayData();
      _loadSnapshots();
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return const Center(child: CircularProgressIndicator());
    }
    if (_snapshots.isEmpty) {
      return const Center(child: Text('Ù„Ù… ÙŠØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø£ÙŠ Ù„Ù‚Ø·Ø§Øª Ù„Ù„Ø¯Ø±Ø¬ Ø¨Ø¹Ø¯.'));
    }

    final groupedSnapshots = groupBy(
      _snapshots,
      (DrawerSnapshot s) => DateFormat('yyyy-MM-dd').format(s.date),
    );

    return ListView.builder(
      padding: const EdgeInsets.symmetric(horizontal: 8),
      itemCount: groupedSnapshots.keys.length,
      itemBuilder: (context, index) {
        final dateKey = groupedSnapshots.keys.elementAt(index);
        final snapshotsForDay = groupedSnapshots[dateKey]!;
        final date = DateTime.parse(dateKey);
        return _buildDaySection(context, date, snapshotsForDay);
      },
    );
  }

  Widget _buildDaySection(
    BuildContext context,
    DateTime date,
    List<DrawerSnapshot> snapshots,
  ) {
    final currencyFormat = NumberFormat.currency(locale: 'ar', symbol: 'Ø¯.Ø¬');
    final startSnapshot = snapshots.firstWhereOrNull(
      (s) => s.type == SnapshotType.start,
    );
    final endSnapshot = snapshots.firstWhereOrNull(
      (s) => s.type == SnapshotType.end,
    );

    return Card(
      margin: const EdgeInsets.symmetric(vertical: 8),
      elevation: 1,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Column(
        children: [
          Padding(
            padding: const EdgeInsets.all(12.0),
            child: Text(
              DateFormat.yMMMMEEEEd('ar').format(date),
              style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16),
            ),
          ),
          const Divider(height: 1),
          if (startSnapshot != null)
            ListTile(
              leading: const CircleAvatar(
                backgroundColor: Colors.blueAccent,
                child: Icon(Icons.play_arrow, color: Colors.white),
              ),
              title: const Text('Ø±ØµÙŠØ¯ Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„ÙŠÙˆÙ…'),
              subtitle: Text(currencyFormat.format(startSnapshot.cashAmount)),
              trailing: IconButton(
                icon: Icon(Icons.delete_outline, color: Colors.red.shade400),
                // --- âœ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‡Ù†Ø§: Ù†Ù…Ø±Ø± ID Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø§Ù„ØªØ§Ø±ÙŠØ® ---
                onPressed: () =>
                    _deleteSnapshot(startSnapshot.id!, SnapshotType.start),
              ),
            ),
          if (endSnapshot != null)
            ListTile(
              leading: const CircleAvatar(
                backgroundColor: Colors.green,
                child: Icon(Icons.stop, color: Colors.white),
              ),
              title: const Text('Ø±ØµÙŠØ¯ Ù†Ù‡Ø§ÙŠØ© Ø§Ù„ÙŠÙˆÙ…'),
              subtitle: Text(currencyFormat.format(endSnapshot.cashAmount)),
              trailing: IconButton(
                icon: Icon(Icons.delete_outline, color: Colors.red.shade400),
                // --- âœ… ÙˆÙ‡Ù†Ø§ Ø£ÙŠØ¶Ù‹Ø§ ---
                onPressed: () =>
                    _deleteSnapshot(endSnapshot.id!, SnapshotType.end),
              ),
            ),
        ],
      ),
    );
  }
}
