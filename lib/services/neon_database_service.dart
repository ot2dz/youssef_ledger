// lib/services/neon_database_service.dart
import 'package:postgres/postgres.dart';
import 'package:crypto/crypto.dart';
import 'dart:convert';

/// Ø®Ø¯Ù…Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø³Ø­Ø§Ø¨ÙŠØ© Neon
class NeonDatabaseService {
  static Connection? _connection;

  /// Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø§ØªØµØ§Ù„ ÙˆØ¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø©
  static Future<bool> _ensureConnection() async {
    try {
      // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ Ø§ØªØµØ§Ù„ØŒ Ù‚Ù… Ø¨Ø¥Ù†Ø´Ø§Ø¡ ÙˆØ§Ø­Ø¯ Ø¬Ø¯ÙŠØ¯
      if (_connection == null) {
        return await connect();
      }

      // Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„Ø­Ø§Ù„ÙŠ
      try {
        await _connection!.execute('SELECT 1');
        return true;
      } catch (e) {
        // Ø§Ù„Ø§ØªØµØ§Ù„ Ù…Ø¹Ø·Ù„ØŒ Ø£ØºÙ„Ù‚Ù‡ ÙˆØ£Ù†Ø´Ø¦ ÙˆØ§Ø­Ø¯Ø§Ù‹ Ø¬Ø¯ÙŠØ¯Ø§Ù‹
        print('âš ï¸ Ø§Ù„Ø§ØªØµØ§Ù„ Ù…Ø¹Ø·Ù„ØŒ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„...');
        try {
          await _connection!.close();
        } catch (_) {}
        _connection = null;
        return await connect();
      }
    } catch (e) {
      print('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØªØµØ§Ù„: $e');
      _connection = null;
      return false;
    }
  }

  /// Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  static Future<bool> connect() async {
    try {
      print('ğŸ”„ Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Neon...');

      _connection = await Connection.open(
        Endpoint(
          host:
              'ep-lingering-cherry-ad9zg49v-pooler.c-2.us-east-1.aws.neon.tech',
          port: 5432,
          database: 'neondb',
          username: 'neondb_owner',
          password: 'npg_TP8agCUdutO0',
        ),
        settings: const ConnectionSettings(
          sslMode: SslMode.require,
          connectTimeout: Duration(seconds: 30),
          queryTimeout: Duration(seconds: 60),
          timeZone: 'UTC',
        ),
      );

      print('âœ… ØªÙ… Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù†Ø¬Ø§Ø­ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Neon!');

      // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„
      await _initializeTables();

      return true;
    } catch (e) {
      print('âŒ ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: $e');
      _connection = null;
      return false;
    }
  }

  /// ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
  static Future<void> _initializeTables() async {
    if (_connection == null) return;

    try {
      // Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
      await _connection!.execute('''
        CREATE TABLE IF NOT EXISTS users (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          email VARCHAR(255) UNIQUE NOT NULL,
          password_hash VARCHAR(255) NOT NULL,
          created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
          updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
        )
      ''');

      // Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©
      await _connection!.execute('''
        CREATE TABLE IF NOT EXISTS backup_data (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
          backup_type VARCHAR(50) NOT NULL DEFAULT 'complete_backup',
          data_json TEXT NOT NULL,
          backup_date TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
          device_info VARCHAR(255),
          backup_size INTEGER DEFAULT 0,
          created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
          updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
        )
      ''');

      // Ø¥Ù†Ø´Ø§Ø¡ ÙÙ‡Ø§Ø±Ø³ Ù„Ù„Ø£Ø¯Ø§Ø¡
      await _connection!.execute('''
        CREATE INDEX IF NOT EXISTS idx_users_email ON users(email)
      ''');

      await _connection!.execute('''
        CREATE INDEX IF NOT EXISTS idx_backup_user_id ON backup_data(user_id)
      ''');

      await _connection!.execute('''
        CREATE INDEX IF NOT EXISTS idx_backup_date ON backup_data(backup_date DESC)
      ''');

      print('âœ… ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ ÙˆØ§Ù„ÙÙ‡Ø§Ø±Ø³');
    } catch (e) {
      print('âŒ Ø®Ø·Ø£ ÙÙŠ ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„: $e');
    }
  }

  /// Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø§ØªØµØ§Ù„ (ping test)
  static Future<bool> testConnection() async {
    try {
      final connected = await _ensureConnection();
      if (!connected) return false;

      print('ğŸ”„ Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø§ØªØµØ§Ù„...');

      // ØªÙ†ÙÙŠØ° Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø¨Ø³ÙŠØ· Ù„Ù„Ø§Ø®ØªØ¨Ø§Ø±
      final result = await _connection!.execute('SELECT 1 as test');

      if (result.isNotEmpty) {
        print('âœ… Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø§ØªØµØ§Ù„ Ù†Ø¬Ø­! Ø§Ù„Ù†ØªÙŠØ¬Ø©: ${result.first[0]}');
        return true;
      } else {
        print('âŒ Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø§ØªØµØ§Ù„ ÙØ´Ù„: Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ØªØ§Ø¦Ø¬');
        return false;
      }
    } catch (e) {
      print('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø§ØªØµØ§Ù„: $e');
      return false;
    }
  }

  /// Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
  static Future<bool> createUsersTable() async {
    try {
      final connected = await _ensureConnection();
      if (!connected) return false;

      print('ğŸ”„ Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†...');

      const createTableQuery = '''
        CREATE TABLE IF NOT EXISTS users (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          email VARCHAR(255) UNIQUE NOT NULL,
          password_hash VARCHAR(255) NOT NULL,
          created_at TIMESTAMP DEFAULT NOW(),
          updated_at TIMESTAMP DEFAULT NOW()
        )
      ''';

      await _connection!.execute(createTableQuery);
      print('âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø¨Ù†Ø¬Ø§Ø­!');

      // Ø¥Ù†Ø´Ø§Ø¡ ÙÙ‡Ø§Ø±Ø³ Ù„Ù„Ø£Ø¯Ø§Ø¡
      await _connection!.execute('''
        CREATE INDEX IF NOT EXISTS idx_users_email ON users(email)
      ''');

      return true;
    } catch (e) {
      print('âŒ Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: $e');
      return false;
    }
  }

  /// Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©
  static Future<bool> createBackupTable() async {
    try {
      final connected = await _ensureConnection();
      if (!connected) return false;

      print('ğŸ”„ Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©...');

      const createTableQuery = '''
        CREATE TABLE IF NOT EXISTS backup_data (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
          backup_type VARCHAR(50) NOT NULL,
          data_json TEXT NOT NULL,
          backup_date TIMESTAMP DEFAULT NOW(),
          device_info VARCHAR(255),
          backup_size INTEGER DEFAULT 0
        )
      ''';

      await _connection!.execute(createTableQuery);
      print('âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­!');

      // Ø¥Ù†Ø´Ø§Ø¡ ÙÙ‡Ø§Ø±Ø³ Ù„Ù„Ø£Ø¯Ø§Ø¡
      await _connection!.execute('''
        CREATE INDEX IF NOT EXISTS idx_backup_user_id ON backup_data(user_id)
      ''');

      await _connection!.execute('''
        CREATE INDEX IF NOT EXISTS idx_backup_date ON backup_data(backup_date)
      ''');

      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¬Ø¯ÙˆÙ„
      final result = await _connection!.execute(
        "SELECT table_name FROM information_schema.tables WHERE table_name = 'backup_data'",
      );

      if (result.isNotEmpty) {
        print('âœ… ØªÙ… Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø¬Ø¯ÙˆÙ„ backup_data ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª');
        return true;
      } else {
        print('âŒ Ù„Ù… ÙŠØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­');
        return false;
      }
    } catch (e) {
      print('âŒ Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©: $e');
      return false;
    }
  }

  /// ØªØ´ÙÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
  static String _hashPassword(String password) {
    final bytes = utf8.encode(password);
    final digest = sha256.convert(bytes);
    return digest.toString();
  }

  /// ØªØ³Ø¬ÙŠÙ„ Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯
  static Future<Map<String, dynamic>> registerUser(
    String email,
    String password,
  ) async {
    try {
      final connected = await _ensureConnection();
      if (!connected) {
        return {'success': false, 'message': 'ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª'};
      }

      print('ğŸ”„ ØªØ³Ø¬ÙŠÙ„ Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯: $email');

      // ØªØ´ÙÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
      final hashedPassword = _hashPassword(password);

      // Ø¥Ø¯Ø±Ø§Ø¬ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯
      final result = await _connection!.execute(
        Sql.named('''
          INSERT INTO users (email, password_hash)
          VALUES (@email, @password_hash)
          RETURNING id, email, created_at
        '''),
        parameters: {'email': email, 'password_hash': hashedPassword},
      );

      if (result.isNotEmpty) {
        final userData = result.first;
        print('âœ… ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­!');
        print(
          'ID: ${userData[0]}, Email: ${userData[1]}, ØªØ§Ø±ÙŠØ® Ø§Ù„ØªØ³Ø¬ÙŠÙ„: ${userData[2]}',
        );

        return {
          'success': true,
          'message': 'ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­',
          'user': {
            'id': userData[0].toString(),
            'email': userData[1],
            'created_at': userData[2].toString(),
          },
        };
      } else {
        return {'success': false, 'message': 'ÙØ´Ù„ ÙÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…'};
      }
    } catch (e) {
      print('âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: $e');
      return {'success': false, 'message': 'Ø®Ø·Ø£ ÙÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: $e'};
    }
  }

  /// ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„
  static Future<Map<String, dynamic>> loginUser(
    String email,
    String password,
  ) async {
    try {
      final connected = await _ensureConnection();
      if (!connected) {
        return {'success': false, 'message': 'ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª'};
      }

      print('ğŸ”„ Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„: $email');

      // ØªØ´ÙÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„Ù…Ø¯Ø®Ù„Ø© Ù„Ù„Ù…Ù‚Ø§Ø±Ù†Ø©
      final hashedPassword = _hashPassword(password);

      // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„ ÙˆÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„Ù…Ø´ÙØ±Ø©
      final result = await _connection!.execute(
        Sql.named('''
          SELECT id, email, created_at
          FROM users 
          WHERE email = @email AND password_hash = @password_hash
        '''),
        parameters: {'email': email, 'password_hash': hashedPassword},
      );

      if (result.isNotEmpty) {
        final userData = result.first;
        print('âœ… ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ù†Ø¬Ø§Ø­!');
        print('ID: ${userData[0]}, Email: ${userData[1]}');

        return {
          'success': true,
          'message': 'ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ù†Ø¬Ø§Ø­',
          'user': {
            'id': userData[0].toString(),
            'email': userData[1],
            'created_at': userData[2].toString(),
          },
        };
      } else {
        print('âŒ Ø¨ÙŠØ§Ù†Ø§Øª ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ ØºÙŠØ± ØµØ­ÙŠØ­Ø©');
        return {
          'success': false,
          'message': 'Ø¨Ø±ÙŠØ¯ Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø£Ùˆ ÙƒÙ„Ù…Ø© Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ø©',
        };
      }
    } catch (e) {
      print('âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„: $e');
      return {'success': false, 'message': 'Ø®Ø·Ø£ ÙÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„: $e'};
    }
  }

  /// Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©
  static Future<Map<String, dynamic>> createBackup(
    String userId,
    String backupType,
    Map<String, dynamic> data, {
    String? deviceInfo,
  }) async {
    try {
      final connected = await _ensureConnection();
      if (!connected) {
        return {'success': false, 'message': 'ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª'};
      }

      print('ğŸ”„ Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…: $userId');

      final dataJson = jsonEncode(data);
      final backupSize = dataJson.length;

      final result = await _connection!.execute(
        Sql.named('''
          INSERT INTO backup_data (user_id, backup_type, data_json, device_info, backup_size)
          VALUES (@user_id, @backup_type, @data_json, @device_info, @backup_size)
          RETURNING id, backup_date
        '''),
        parameters: {
          'user_id': userId,
          'backup_type': backupType,
          'data_json': dataJson,
          'device_info': deviceInfo ?? 'Unknown',
          'backup_size': backupSize,
        },
      );

      if (result.isNotEmpty) {
        final backupData = result.first;
        print('âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­!');
        print('ğŸ†” Ù…Ø¹Ø±Ù Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©: ${backupData[0]}');
        print('ğŸ“… ØªØ§Ø±ÙŠØ® Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©: ${backupData[1]}');

        return {
          'success': true,
          'message': 'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­',
          'backup_id': backupData[0].toString(),
          'backup_date': backupData[1].toString(),
          'backup_size': backupSize,
        };
      } else {
        return {'success': false, 'message': 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©'};
      }
    } catch (e) {
      print('âŒ Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©: $e');
      return {
        'success': false,
        'message': 'Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©: $e',
      };
    }
  }

  /// Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø§Ù„Ø£Ø­Ø¯Ø« Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
  static Future<Map<String, dynamic>> getLatestBackup(
    String userId, {
    String? backupType,
  }) async {
    try {
      final connected = await _ensureConnection();
      if (!connected) {
        return {'success': false, 'message': 'ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª'};
      }

      print('ğŸ”„ Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø§Ù„Ø£Ø­Ø¯Ø« Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…: $userId');

      String query = '''
        SELECT id, backup_type, data_json, backup_date, device_info, backup_size
        FROM backup_data 
        WHERE user_id = @user_id
      ''';

      Map<String, dynamic> parameters = {'user_id': userId};

      if (backupType != null) {
        query += ' AND backup_type = @backup_type';
        parameters['backup_type'] = backupType;
      }

      query += ' ORDER BY backup_date DESC LIMIT 1';

      final result = await _connection!.execute(
        Sql.named(query),
        parameters: parameters,
      );

      if (result.isNotEmpty) {
        final backupData = result.first;
        final dataJson = backupData[2] as String;
        final data = jsonDecode(dataJson);

        print('âœ… ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©!');
        print('ğŸ“… ØªØ§Ø±ÙŠØ® Ø§Ù„Ù†Ø³Ø®Ø©: ${backupData[3]}');

        return {
          'success': true,
          'message': 'ØªÙ… Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­',
          'backup': {
            'id': backupData[0].toString(),
            'backup_type': backupData[1],
            'backup_date': backupData[3].toString(),
            'device_info': backupData[4],
            'backup_size': backupData[5],
          },
          'data': data,
        };
      } else {
        print('ğŸ“‹ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…');
        return {
          'success': false,
          'message': 'Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ù„Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…',
        };
      }
    } catch (e) {
      print('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©: $e');
      return {
        'success': false,
        'message': 'Ø®Ø·Ø£ ÙÙŠ Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©: $e',
      };
    }
  }

  /// Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
  static Future<Map<String, dynamic>> getUserBackups(String userId) async {
    try {
      final connected = await _ensureConnection();
      if (!connected) {
        return {'success': false, 'message': 'ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª'};
      }

      print('ğŸ”„ Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…: $userId');

      final result = await _connection!.execute(
        Sql.named('''
          SELECT id, backup_type, backup_date, device_info, backup_size
          FROM backup_data 
          WHERE user_id = @user_id
          ORDER BY backup_date DESC
        '''),
        parameters: {'user_id': userId},
      );

      final backups = result
          .map(
            (row) => {
              'id': row[0].toString(),
              'backup_type': row[1],
              'backup_date': row[2].toString(),
              'device_info': row[3],
              'backup_size': row[4],
            },
          )
          .toList();

      print('âœ… ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ${backups.length} Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©');

      return {
        'success': true,
        'message': 'ØªÙ… Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­',
        'backups': backups,
      };
    } catch (e) {
      print('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©: $e');
      return {
        'success': false,
        'message': 'Ø®Ø·Ø£ ÙÙŠ Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©: $e',
      };
    }
  }

  /// Ù‚Ø·Ø¹ Ø§Ù„Ø§ØªØµØ§Ù„
  static Future<void> disconnect() async {
    try {
      if (_connection != null) {
        await _connection!.close();
        _connection = null;
        print('âœ… ØªÙ… Ù‚Ø·Ø¹ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù†Ø¬Ø§Ø­');
      }
    } catch (e) {
      print('âŒ Ø®Ø·Ø£ ÙÙŠ Ù‚Ø·Ø¹ Ø§Ù„Ø§ØªØµØ§Ù„: $e');
    }
  }

  // Getters
  static Connection? get connection => _connection;
  static bool get isConnected => _connection != null;
}
